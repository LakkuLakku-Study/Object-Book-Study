- 문제를 해결하기 위해서 필요한 정보를 단기 기억 안으로 불러와야하는데 필요한 정보가 너무 많으면 문제 해결 능력은 떨어짐 → 인지 과부하 → 정보의 양을 줄여야 한다.
- 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업 → 추상화
- 일반적인 추상화 방법 = 한 번에 다뤄야 하는 문제의 크기를 줄이는 것
    - 큰 문제를 해결 가능한 작은 문제로 나누는 작업 → “분해”

- 분해의 목적
    - 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누기
    - ex) 11자리 정수 8개를 한 번에 외우기 → 전화번호라는 개념적 청크(단위)로 묶으면 11자리 전화번호 8개가 되므로 인지 능력을 향상 가능

# 1) 프로시저 추상화와 데이터 추상화

- 프로그래밍 언어
    - → 인간이 이해할 수 있는 상징을 부여하여 단순히 숫자가 아니게 되었다.
    - 이는 추상화를 제공하려는 시도의 결과임
- 프로그래밍 언어를 통해 표현되는 추상화의 발전은 → “다양한 프로그래밍 패러다임”으로 탄생함
    - 프로그래밍 패러다임의 2가지 요소
        1. 프로그래밍을 구성하기 위해 사용하는 추상화의 종류 
        2. 이 추상화를 이용해 소프트웨어를 분해하는 방법 
- 프로그래밍 언어를 특징 짓는 중요한 2가지 추상화 메커니즘 → 프로시저 추상화 and 데이터 추상화
    - 프로시저 추상화는 소프트웨어가 **무엇을 해야하는지를 추상화**
    - 데이터 추상화는 소프트웨어가 **무엇을 알아야 하는지를 추상화**
- 먼저 시스템을 분해하는 방법을 결정하려면 먼저 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지 결정해야한다.
- **프로시저 추상화**
    - 소프트웨어가 무엇을 해야하는지 추상화
    - 프로시저는 리턴값이 없는 로직 묶음
    - 데이터 조작
    - 시스템을 분해하는 방법으로 먼저 프로시저 추상화를 중심으로 하게 된다면 먼저 기능 분해(functional decomposition) == 알고리즘 분해(algorithmic decomposition)를 하는 것이다.
- **데이터 추상화**
    - 소프트웨어가 무엇을 알아야 하는지 추상화
    - 정보 표현
    - 데이터 추상화를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 한다.
        - **추상 데이터 타입(Abstract Data Type)**
            - 데이터를 중심으로 **타입을 추상화(type abstraction)**하는 것
        - **객체지향(Object-Oriented)**
            - 데이터를 중심으로 **프로시저를 추상화(procedure abstraction)**하는 것
- 역할과 책임을 수행하는 객체가 객체지향 패러다임이 이용하는 추상화다.
    - 기능을 협력하는 공동체를 구성하도록 객체들로 나누는 과정이 객체 지향 패러다임에서의 분해를 의미한다.
- 프로그래밍 언어 관점에서 객체지향이란 데이터를 중심으로 추상화와 프로시저 추상화를 함께 포함한 객체를 이용해 시스템을 분해하는 방법이다.
    - 이런 객체를 구현하기 위해 대부분의 객체 지향 언어는 클래스라는 도구를 제공ㅎ나다.
    - 따라서, 프로그래밍 언어적인 관점에서 객체 지향을 바라보는 일반적인 관점은 “데이터 추상화와 프로시저 추상화”를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다.

- 전통적인 기능 분해 방법에서 시작해서 객체 지향 분해 방법에 이르는 역사를 살펴보자.

# 2) 프로시저 추상화와 기능 분해

## 메인 함수로서의 시스템

- 기능은 오랜 시간동안 시스템을 분해하기 위한 기준으로 사용되었다.
    - 이를 알고리즘 분해 또는 기능 분해라고 부른다.
    - 기능 분해의 관점에서 추상화의 단위는 프로시저이며, 시스템은 프로시저를 단위로 분해된다.
    - 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.
        - 프로시저를 추상화라고 부르는 이유는 내부 상세 구현을 모르더라도 인터페이스만 알면 프로세저를 사용할 수 있기 때문이다.
        - 하지만 효과적인 정보 은닉 체계를 구축하는 데 한계가 있다.
- 전통적인 기능 분해 방법은 **하향식 접근법(Top-Down Approach)**를 따른다.
    - 하향식 접근법이란 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고,
    - 이 최상위 기능을 좀 더 작은 단계의 하위 기능 집합으로 분해해 나가는 방법을 말한다.
    - 각 세분화 단계는 바로 위 단계보다 더 구체적이어야 한다.
    - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능할 수준이 될 때까지 계속한다.

## 급여 관리 시스템

> 급여 = 기본급 - (기본급 * 소득세율)
> 
- 급여 관리 시스템을 구현하기 위해 기능 분해 방버 이용
    - 하향식 접근법
    - 최상위의 추상적인 함수 정의에서 출발하여 단계적인 정제 절차를 따라 시스템을 구축한다.
        - 각 정제 단계는 이전 문장의 추상화 수준을 감소시켜야 한다.
        - 하나 이상의 좀 단순하고 구체적인 문장들의 조합으로 분해되어야 한다.
- 최상위 문장  ⇒ “직원의 급여를 계산한다”
    - 세분화된 절체로 구체화한다.
    - “사용자로 부터 소득세율을 입력받음”
    - “직원의 급여를 계산함”
    - “양식에 맞게 결과를 출력”
- 정제 과정 한 번 더 거친다.
    - 최상위 문장  ⇒ “직원의 급여를 계산한다”
        - “사용자로 부터 소득세율을 입력받음”
            - “세율을 입력하세요 “라는 문장을 화면에 출력한다.
            - 키보드를 통해 세율을 입력받는다.
        - “직원의 급여를 계산함”
            - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
            - 급여를 계산한다.
        - “양식에 맞게 결과를 출력”
            - 이름 : {직원 명}, 급여 : {계산된 금액} 형식에 따라 출력 문자열을 생성한다.
- 기능 분해의 결과
    - 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것이다.
- 기능 분해 방법은 기능을 중심으로 필요한 데이터를 결정한다.
    - 필요 기능을 먼저 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.
- 단점
    - 유지보수 문제가 있다.

## 급여 관리 시스템 구현

- 위에서 분해했으니 이제 코드로 구현해보자
- 최상위 문장인 “급여를 계산한다”는 하나의 메인 함수로 매핑
    
    ```java
    def main(name) // 직원의 이름을 인자로 받음 
    end
    ```
    
- 최상위 함수를 구현하기 위해 세분화한 내용을 채운다.
    
    ```java
    def main(name) // 직원의 이름을 인자로 받음 
    	taxRate = getTaxRate() // 소득세율을 입력
    	pay = calculatePayFor(name, taxRate) // 급여를 계산
    	puts(describeResult(name, pay)) // 결과 출력 
    end
    ```
    
- 이때, getTaxRate() 함수는 또 2개의 절차로 분해할 수 있다.
    - 화면 출력 + 세율 입력받기
    
    ```java
    def getTaxRate()
    	print("세율을 입력")
    	return gets().chomp().to_f()
    end
    ```
    
- 이렇게 하다보면 메인 함수를 루트로 하는 “트리”로 표현할 수 있다.
    - 노드 → 시스템을 구성하는 하나의 프로시저
    - 자식 노드 → 부모 노드를 구현하는 절차 중 한 단계를 의미
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/d019f03a-e563-4070-b5a9-ab74e20061fe/image.png)
        
- 위 그림만 보면 논리적, 구조적, 체계적인 동시에 이상적으로 보인다.
    - 체계적이고 이상적인 방법이 불규칙하고 불완전한 인간과 만나는 지점에서 혼란과 동요가 발생한다.

## 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
    - 모든 기능을 자식 노드로 가지는 하나의 메인 기능을 선택할 수 없다.
        - 대부분의 시스템에서 존재하지 않는다.
        - 기능적인 측면에서 동등하게 독립적이고 완결된 하나의 기능을 표현해야 한다.
- **기능 추가나 요구사항 변경 발생 시  메인 함수를 매번 수정해야 한다.**
    - 기존 로직과 상관 없는 함수가 들어오면 메인 함수를 수정해야 한다.
    - 지금까지 우리는 조건 추사 시 원래 코드를 수정하지 않는 방법들을 배웠다.
        - 시스템은 여러 정상들이 결합되어 있는 것인데 하향식은 main을 하나의 정상으로 보기 때문에 수정이 빈번한다.
        - 아래와 같이 하나의 정상이라고 간주한 main 함수를 수정해야한다.
        
        !https://velog.velcdn.com/images/pp8817/post/a7610db4-1bc8-4b12-9a3a-720d509e9f0b/image.png
        
- **비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.**
    - 설계 초기부터 입출력을 함께 고민하도록 한다.
        - 사용자 인터페이스의 관심사와 비즈니스 로직의 관심사를 동시에 고려하도록 강요하게 된다.
        - main에 비즈니스 로직과 입출력 로직이 섞여있어 인터페이스를 변경하려면 전체 구조를 재설계해야 한다.
- **하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.**
    - 하향식 분해는 하나의 함수를 더 작게 분해하며, 함수들의 실행 순서를 결정한다.
        - 실행 순서를 정의하는 시간 제약을 강조하게 된다.
    - 이것은 what(무엇)이 아니라 how(어떻게 )에 집중하는 것이다.
        - 직원 급여를 계산하기 위한 작업을 순서대로 해야 한다.
            - 소득세율을 입력 받는 작업, 급여를 계산하는 작업, 계산된 결과를 화면에 츨력하는 작업
        
    - 함수는 상위 함수가 강요하는 문맥에 시간(순서)적으로 강하게 결합된다.
        - 메인 함수가작은 함수로 분해되려면 우선 순서를 정해야 한다.
            - 실행 순서, 반복, 조건과 같은 제어 구조를 정해야 해서 중앙 집중 스타일이 될 수밖에 없다.
        - 강한 결합도는 시스템을 변경에 취약하게 만들고 이해하기 어렵게 만든다.
        - 시간 순서 가 아닌 논리적 제약을 설계의 기준으로 삼아야 한다.
- 함수가 재사용 되려면 일반적이어야 한다.
    - 하위 함수는 항상 상위 함수 문맥에 종속정이다. 이는 재사용성에 반대된다.
    - 이는 결합도를 높이고, 강한 결합도는 시스템을 변경에 취약하게 만들면서, 이해하기 어렵게 만든다.
- 데이터 형식이 변경될 경우 파급 효과를 예측할 수 없다.
    - 하향식 기능 분해의 가장 큰 문제점
    - 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려움
        - 어떤 데이터가 어떤 함수에 의존하고 있는지는 모든 함수를 열어 데이터 사용 여부를 찾아봐야 한다.
        - 전역변수가 수정되었다고 기존 함수를 수정해야 할 것이라는 생각을 하기가 어렵다.
    - 변경의 영향을 최소화하기 위해서 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야한다.
        - 데이터와 함께 변경되는 부분을 하나의 구현단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근해야한다.
            - 즉, 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다.
            - 이 같은 개념을 기반으로 한 정보 은닉과 모듈이라는 개념을 제시하게 되었다.

> 하나의 함수에 제어가 집중되기 때문에 확장이 어렵다.
> 
> 
> 과도하게 함수에 집중하게 하여 데이터에 대한 영향도를 파악하기 어렵게 함
> 
> 재사용 어려움 
> 
> 사용자 인터페이스 같은 비본질적인 측면에 집중 
> 

## 언제 하향식 분해가 유용한가?

- 완전히 이해된 사실을 서술할 때 적합

# 3) 모듈

## 정보 은닉과 모듈

시스템 변경 관리 기본 전략은 함께 변경되는 방향으로 기능과 데이터를 묶어 퍼블릭 인터페이스로만 접근할 수 있게 하는 것이다.

**[ 정보 은닉]**

- 시스템을 모듈 단위로 분리 기본 원리
- 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다
    - 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.

- 모듈은 다음 두 가지 비밀을 감춰야 한다.
    - 복잡성 : 모듈을 추상화하는 간단한 인터페이스를 제공하여 내부 로직의 복잡도를 낮춘다.
    - 변경 가능성 : 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

- 가장 큰 비밀은 데이터지만, 복잡한 로직이나 변경 가능성 큰 자료구조일 수 있다.
    - 데이터 캡슐은 정보 은닉의 한 종류일 뿐
- 자바에서 모듈의 개념은 “패키지”를 이용해 구현 가능하다.
- 

## 모듈의 장점과 한계

### 장점

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
    - 모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.
    - 이제 어떤 데이터가 변경되었을 때 영향을 받는 함수는 해당 데이터를 정의한 모듈만 검색하면 된다.
    - 즉, 전체 함수들을 뒤져볼 필요가 없다. 데이터 변경으로 인한 파급효과를 제어한다,
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
    - 사용자 인터페이스는 Employee 외부에서 담당한다.
    - 모듈은 비즈니스 로직을 담당하는 인터페이스만 제공한다
    - 즉, 다른 사용자 인터페이스가 추가되더라도 사용되는 모듈의 비즈니스 로직은 변하지 않는다.
- 전역 변수와 전역 함수를 제거함으로써 **네임스페이스 오염(namespace pollution)**을 방지한다
    - 모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.
    - 변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할수 있다.
    - 즉 전역 네임 스페이스를 오염을 방지하는 동시에 **이름 충돌(name collision)**의 위험을 완화한다.

모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.

각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터,함수 집합이다.

따라서 모듈 내부는 응집도가 높다.

모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신할 수 있다.

따라서 낮은 결합도를 유지한다.

### 단점

- 인스턴스 개념을 제공하지 않는다.
    - 좀 더 높은 수준의 추상화를 위해선, Employees 모듈이 전체 직원들을 다루는게 아니라
    개별 직원을 독립적인 단위로 다룰 수 있도록 해야 한다.
    - 즉 다수의 인스턴스가 필요하다.
    - 이를 위해 등장한 개념이 추상 데이터 타입이다.

# 4) 데이터 추상화와 추상 데이터 타입

## 추상 데이터 타입

- 프로그래밍 언어에서 타입(type)이란
    - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.
- 타입을 통해 저장된 값에 대해 수행될 수 있는 연산이 정해진다.
    - 따라서 변수의 값의 행동을 예측할 수 있다.
    - 정수 타입의 변수는 덧셈 연산을 이용해 값을 더할 수 있다.

- 리스코프는 소프트웨어를 이용해 표현할 수 있는 추상화의 수준을 한단계 높였다.
    - 프로시저 추상화 대신 데이터 추상화 기반으로 개발하기 위한 첫걸음
    - ex) “직원의 급여를 계산한다”라는 하나의 커다란 절차를 이용해 사고하기보다는 “직원”, “급여”라는 추상적인 개념들을 머릿속에 떠올린 후 이들을 이용해 계산에 필요한 절차를 생각하는 것이다.
- 추상 데이터 타입 구현을 위한 프로그래밍 언어의 기능
    - 타입 정의 선언
    - 타입 인스턴스를 다루기 위한 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
    - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
    - 타입에 대해 여러개의 인스턴스 생성 가능해야 한다.
- 자바 예시
    
    자바에서 추상 데이터 타입은 주로 **인터페이스**나 **추상 클래스**를 사용하여 구현됩니다. 이는 사용자에게 **구현 세부 사항을 감추고**, **데이터와 연산의 규약**만을 노출하는 방식으로, 이를 통해 코드를 더 **모듈화**하고, 유지보수를 용이하게 할 수 있습니다.
    
    ```java
    public interface StackADT<T> {
        void push(T item);    // 데이터 추가
        T pop();              // 데이터 제거 및 반환
        T peek();             // 최상단 데이터 확인
        boolean isEmpty();    // 스택이 비어있는지 확인
    }
    
    ```
    
- 추상 데이터 타입은 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킴
    - Employee는 상태와 행위를 가진 독립적인 주체라고 사람들이 생각함
- 추상 데이터 타입은 구조체랑 비슷함.
    - 여전히 데이터와 기능을 분리
    - 말 그대로 시스템의 상태를 저장할 데이터를 표현한다.
    - 핵심 로직 추상 데이터 타입 외부에 존재한다.
- 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입처럼, 사용자 정의타입을 추가할 수 있게 하는것이다.

# 5) 클래스

## 클래스는 추상 데이터 타입인가?

- 클래스와 추상 데이터 타입은 모두 데이터 추상화를 기반으로 시스템을 분해한다는 점에서는 비슷하지만 엄밀히 말해서는 추상 데이터 타입은 상속과 다형성을 지원하지 않기 때문에 클래스와 다르다고 할 수 있다.
    - 상속과 다형성을 지원하는 → 객체 지향 프로그래밍
    - 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 → 객체 기반 프로그래밍
- 추상화하는 대상이 다르다.
    - 클래스 → 절차을 추상화한 것
        - 절차 추상화?
            - 타입을 기준으로 절차들을 추상화한다.
                - 다형성을 이용하여 부모클래스에 공통기능을 적용하고 각 타입에 맞게(알바, 정직원) 다르게 클래스를 구성하여 구현한다.
                - 클라이언트 관점에서 인스턴스는 동일하게 보인다.
                    - 즉, 실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.
                    
                    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/6ac87c7b-088d-4294-842a-05e22ebf290e/image.png)
                    
    - 추상 데이터 타입 → 타입을 추상화
        - 타입 추상화란?
            - 하나의 물리적인 타입 안에 전체 타입을 감춘다.
            - 추상 데이터 타입은 물리적으로 하나의 타입처럼 보이는 Employee 타입 내에 개념 2개(직원, 알바)가 공존함
                
                ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/36adc896-4ff8-44a2-a7c4-2e964b65c0fe/image.png)
                
            - 알바가 calcultatePay를 실행하는 것과 정규 직원이 calculatePay를 실행하는 내부 로직이 다르다. 알바는 시급, 정규직은 월급
                - 알바, 정직원 종류를 Employee로 묶고 같은 메서드를 사용하지만 내부 로직은 다르다.
                - 이렇듯, **오퍼레이션을 기준으로 타입을 통합한다.  (객체 지향은 타입을 기준으로 오퍼레이션을 묶는다 → 정직원과 알바를 각각 클래스로 만들고 이에 맞게 calculatePay를 구현한다. )**
                
                ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/b9a4589a-fd6e-4f88-8e88-783c11a4ffec/image.png)
                

## 추상 데이터 타입에서 클래스로 변경하기

- 추상 데이터 타입에서는 하나의 Employee 타입 안에 두 가지 직원 타입을 캡슐화했다.
    - 각 직원 타입을 독립적인 클래스로 구현하자 → 두 개의 타입이 존재한다는 사실을 명시적으로 표현한다.
- 부모 Employee
    - 자식 SalariedEmployee , HourlyEmployee
- 클라이언트는 자식의 종류에 상관없이 Employee의 인스턴스라고 생각하고 다루면 되기 때문에 신경쓸 게 없어진다.

## 변경을 기준으로 선택하라

- 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 의미는 아니다.
    - 비록 클래스를 “사용”하고 있어도 타입을 기준으로 추상화하지 않았다면 그것은 객체지향 분해가 아니다.
- 클래스가 추상 데이터 타입의 개념을 따르는지 확인할 수 있는 방법
    - 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지 살펴보기
        - ex) Employee에서 직원과 알바를 구분하기 위해 hourly 변수를 사용하여 구분 → 객체 지향 위반!
        - 객체 지향이란 조건문을 제거하는 것이라고까지 표현할 수 있다.
            - 새로운 직원 타입이 생기면 hourly값을 체크하는 클라이언트 조건문을 하나씩 다 수정해야한다. ↔ 객체 지향은 클래스 추가하고 그냥 메서드 오버라이딩하면 된다.
- 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체 지향의 특성을 “개방-폐쇄 원칙”이라고 한다.

- 무조건 객체지향이 좋다는 것이 아니다.
    - 설계에서 변경이 일어날 때
        - “타입 추가”가 일어나는지 → 객체 지향 방식 적합
        - “오퍼레이션 추가”가 일어나는지 → 추상 데이터 타입을 선택한다.
            - 하나의 오퍼레이션 추가 일어나면 모든 클래스 타입에 해당 오퍼레이션을 추가해야한다. ㅜ

## 협력이 중요하다.

- 지금까지 본 것은 그냥 추상 데이터 타입과 클래스의 차이를 보여주기 위한 것이지 객체를 설계하는 방법을 설명한 것은 아니다.
    - 객체를 설계하는 방법은 책임 주도 설계의 흐름을 따라야한다.
- 협력이라는 문맥을 고려해서 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지 고민하고
    - 그 책임을 다양한 방식으로 수행할 때만 타입 계층 안에 각 절차를 추상화하라
- 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 한다. 그 자체가 목적이 되어서는 안 된다.
