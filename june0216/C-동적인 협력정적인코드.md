- 협력을 구성하기 위해 “살아 움직이는 객체”가 필요하다.
    - 객체는 동적이다.
        - 객체의 상태를 지속적으로 변하고 외부의 자극에 따라 다양한 방식으로 행동하기 때문
- 객체는 동적이지만 이를 표현하기 위한 프로그래밍이라는 도구는 정적이다.
    - 그렇기 때문에 프로그램은 고정된 텍스트라는 형식 안에 갇혀 있으면서도 객체의 모든 변화 가능성을 담아야 한다.
- 객체 지향 프로그램을 작성하기 위해서 정적 모델과 동적 모델을 동시에 조화롭게 고려해야 한다.
    - 동적 모델 : 프로그램 실행 구조를 표현하는 움직이는 모델
        - 객체와 협력으로 구성하며 협력하며 기능을 수행한다.
    - 정적 모델 : 코드의 구조를 담는 고정된 모델
        - 타입과 관계로 구성된다.
        - 타입은 객체를 분류하기 위한 틀 → 타입에 속하는 객체들이 수행할 수 있는 모든 행동들을 압축해서 표현한 것이다.
- 이 두 가지 모델 중 어떤 것을 우선해야할까?
    - 동적 모델이 중요하다
    - 정적 모델은 동적 모델에 의해 주도돼야 하고 동적 모델이라는 토대 위에 세워져야 한다.
- 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 **`변경`**이다.
    - 설계가 필요한 이유는 변경을 수용할 수 있는 코드를 만들기 위해서이다.
        - 변경을 수용할 수 있는 코드 → 단순하고 결합도가 낮으며 중복 코드가 없는 코드
- 이를 위해 코드가 아닌 협력에 초점을 맞춰야 한다.

# 1) 동적 모델과 정적 모델

## 행동이 코드를 결정한다.

- 협력에 참여하는 객체의 행동이 객체의 정적 모델을 결정해야한다.
- 새 - 펭귄
    - 만약 개념 사이의 관계에 기반한다면
        
        ![스크린샷 2024-12-26 오후 6.43.03(2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/ddf8b81c-4afe-42f0-b7a6-c4852f019ff0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.43.03(2).png)
        
    - 만약 리스코프 치환 원칙을 고려하여 fly 행동을 고려한다면
        - 객체가 외부에 fly라는 행동을 제공한다면
        
        ![스크린샷 2024-12-26 오후 6.43.01(2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/7cceb1eb-843d-4640-b084-5813dbcd927e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.43.01(2).png)
        
- 즉, 객체의 행동을 고려하지 않은 경우 ( 개념만 고려한 설계) 날 수 있는 펭귄이라는 예상과 다른 결과가 나올 수 있다.
    - 객체의 정적 모델은 동적 모델이라는 토대 없이 완전해질 수 없다.
    - 가장 중요한 것은 객체가 외부에 제공하는 행동이다.
    - 동적 모델이 정적 모델을 결정해야한다. (정적 모델을 설계하는 이유는 단지 행동과 변경을 적절하게 수용할 수 있는 코드 구조를 찾는 것이어야 한다)

## 변경을 고려하라

- 변경을 고려하지 않고 상속으로 관계를 설정 하는 경우
    
    ![스크린샷 2024-12-26 오후 7.04.43(2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/10ecee0a-d8d8-4ac0-b6fe-c577cf396afa/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.04.43(2).png)
    
- 상속 관계에서 합성으로 변경하면 요금을 다양하게 조합하더라도 중복 코드가 발생하지 않는다.
    
    ![스크린샷 2024-12-26 오후 7.04.46(2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/2f4cd697-f4ed-42de-8411-7f8766eaccb5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.04.46(2).png)
    

# 2) 도메인 모델과 구현

- 도메인 모델을 먼저 만들고 도메인 모델을 기반으로 설계와 구현을 진행하라는 이야기를 볼 수 있다.
    - 그러면 정적인 모델을 기반으로 협력을 설계하는 것 아닌가?라는 의문이 들 수 있다.

## 도메인 모델에 관하여

- 도메인
    - 사용자가 프로그램을 사용하는 대상 영역을 가리킨다.
- 모델
    - 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태
- 도메인 모델
    - 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화함
- 보통, 도메인 모델을 기반으로 소프트웨어를 구축하라고 하는데 도메인 모델을 작성하는 것이 목표가 아니라 출발점이다.
    - 여기서 잘못된 코드 구조를 낳는 원인이 발생할 수 있다.
        - 오해 1 : 도메인 안의 개념이 제공하는 틀에 맞춰서 구성하지 말하야 한다는 점
        - 오해 2: 도메인 모델이 클래스 다이어그램과 같은 정적 모델에 기반해야한다
    - 도메인 모델은 도메인에 대한 지식을 표현하고 코드의 구조에 대한 힌트를 제공할 수 있다면 **어떤 형태로 표현하더라도 상관없다.**
    - 중요한 것은 소프트웨어의 기능과 객체의 책임이다.
    - → 도메인 안의 개념들을 기반으로 출발하되, 객체들의 협력이 도메인 모델에 맞지 않는다면 필요한 몇 가지 개념만 남기고 도메인 모델을 과감히 수정하라
    - 제약 상황에 집착하는 것이 아니라 객체들의 협력을 지원하는 코드 구조를 만드는 것을 목표로 하라

## 몬스터 설계하기

- 변경에 유연하게 대응할 수 있는 타입의 구현 방법
    - Monster가 있고 이 종류들이 확장 가능하다고 하자
- 먼저, 추상 클래스로 Monster를 만들고 이를 상속 받아 구현해볼 수 있다.
    
    ```java
    public abstract class Monster {
        private int health;
        
        public Monster(int health) {
            this.health = health;       
        }
        
        abstract public String getAttack();
    }
    
    public class Dragon extends Monster {
        public Dragon() {
            super(230);
        }
        
        @Override
        public String getAttack() {
            return "용은 불을 내뿜는다";
        }
    }
    ```
    
    - 하지만 몬스터 종류가 추가되면 새로운 클래스를 만들고 오버라이딩 매 번 해야하므로 귀찮을 수 있다.
        - 추가하고자 할 때 더 쉽게 추가할 수 있도록 개선해보자
        - ⇒ 몬스터가 품종을 가지도록 설계하면 새로운 몬스터를 추가하는 요구사항이 올 때, 클래스를 추가하는 대신 합성하여 구현할 수 있다.
            
            ```java
            public class Breed {
                private String name;
                private int health;
                private String attack;
                
                public Breed(String name, int health, String attack) {
                    this.name = name;
                    this.health = health;
                    this.attack = attack;
                }
                
                public int getHealth() {
                    return health;
                }
                
                public String getAttack() {
                    return attack();
                }
            }
            ```
            
            ```java
            public class Monster {
                private int health;
                private Breed breed;
                
                public Monster(Breed breed) {
                    this.health = breed.getHealth();
                }
                
                public String getAttach() {
                    return breed.getAttack();
                }
            }
            
            Monster dragon = new Monster(new Breed("용",230,"용은 불을 내뿜는다"));
            Monster troll = new Monster(new Breed("트롤",48,"트롤은 곤봉으로 때린다"));
            ```
            
- 새로운 클래스를 추가하는 대신 새로운 인스턴스를 생성하는 것으로 타입 추가문제를 해결했다.
- 어떤 객체를 표현하는 별도의 객체를 이용해 타입을 구현-> Type Object 패턴이라고 부른다.
    - Breed 인스턴스가 Monster 타입을 구현하는 Type Object 에 해당

## 행동과 변경을 고려한 도메인 모델

- 행동과 변경을 고려하지 않는 도메인 모델을 그대로 따르는 건 코드의 유지보수를 방해하게 된다.
    
    ![스크린샷 2024-12-26 오후 9.04.17(2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/4d5656aa-2765-4137-bd10-e740d087d93f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.04.17(2).png)
    
    - 위의 그림은 도메인 안에 용과 트롤이 존재하는데 이것이 드러나지 않는다.
        - 아래와 같이 몬스터 종류들을 **`JSON 형식으로 서술`**하면 → 도메인 전체에 대한 이해가 더 쉬워질 것이다.
        - → C.6 그림과 Json 조합이 게임 안에서의 도메인 모델이라고 할 수 있다.
    
    ```java
    {
        "breeds" : 
        [
            {"name" : "용", "health" : 230, "attack" : "용은 불을 내뿜는다"},
            {"name" : "트롤", "health" : 48, "attack" : "트롤은 곤봉으로 때린다"},
        ]
    }
    ```
    
    - 도메인 모델은 단순히 클래스 다이어그램이 아니며 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이 도메인 모델이다.
    - 즉, 도메인의 핵심을 간략하게 단순화해서 코드에 대한 구조와 행동을 표현할 수 있는 모든 것이 도메인 모델이다.
- 정리하자면, 도메인 모델이 단순히 정적 모델의 형태를 띨 필요가 없으며 도메인 모델의 구조가 코드와 다를 필요가 없다.
    - 도메인 모델은 코드를 위한 것이다.
    - 도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야한지만 최종 모습은 객체의 행동과 변경에 기반해야하며 코드의 구조를 반영해야한다.
        - 도메인 모델을 봤을 때 도메인의 **개념뿐만 아니라 코드도 함께 이해될 수 있는 구조**를 찾자
        - 아래의 그림이 동적 모델을 가장 잘 표현할 수 있는 구조로 코드를 작성하려고 노력한 그림이 아래의 정적 모델이다.
            
            ![스크린샷 2024-12-26 오후 7.04.46(2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/2f4cd697-f4ed-42de-8411-7f8766eaccb5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.04.46(2).png)
            

## 분석 모델, 설계 모델, 구현 모델

- **분석 모델**: 문제를 기술하는 초기 단계로, 비즈니스 요구사항이나 사용자의 필요를 기반으로 시스템의 기능과 구조를 이해하는 데 초점을 맞춥니다. 주로 비즈니스 관점에서 문제를 추상적으로 설명합니다.
    - 해결 방법에 대한 언급 없이 문제 도메인을 설명하는 모델
    - 순수하게 문제 도메인에 초점을 맞춰야 한다.
    - 기술적인  해결 방법을 언급해서는 안된다.
    - 예: "사용자가 로그인하고 데이터를 검색하는 기능이 필요하다."
- **설계 모델**: 분석 모델을 바탕으로 실제 개발에 필요한 기술적인 관점에서 솔루션을 구체화합니다.
    - 예: "로그인 시스템은 인증 API를 사용하며, 데이터 검색은 데이터베이스의 특정 쿼리를 통해 처리된다."
- **구현 모델**: 설계 모델을 기반으로 실제 코드로 작성된 소프트웨어입니다.
    - 예: 로그인 기능을 Python이나 Java 같은 언어로 구현하고, 데이터 검색 쿼리를 SQL로 작성합니다.
- 분석 모델, 설계 모델, 구현 모델 흐름
    - **`분석 모델`**이 완성되면 이를 바탕으로 기술적인 관점에서 솔루션을 서술하는 **`설계 모델`**이 만들어진다.
        - 이를 기반으로 `구현 모델`을 만들고 → 프로그래밍 언어를 통해 컴퓨터가 이해할 수 있는 명령어로 변환한다.
- 하지만 분석 모델, 설계 모델, 구현 모델은 명확하게 구분하는 것은 가능하지 않다.
    - 우리가 원하는 것은 설계와 구현 동안 동일한 모델을 유지하는 것이다.
    - 객체 지향 패러다임만의 장점으로 소프트웨어를 개발하기 위한 전체 주기 동안 동일한 설계 기법과 모델링 방법을 사용할 수 있다는 것이다.
        - 클래스, 객체, 메서드 등 현실 세계의 개념을 직접적으로 표현할 수 있어, 분석 → 설계 → 구현의 과정에서 일관성을 유지하기 쉽다.
- 만약, 설계 모델의 일부가 적용 기술 내에서 구현이 불가능하다면 설계 모델을 변경해야한다.
    - 모델과 코드 간의 관계에 강요하면 안된다.
- 코드와 모델의 차이를 줄이기 위해서는 **도메인과 코드 간의 차이가 적어야 한다.**
    - 도메인과 코드 간의 차이가 적다는 것은, 현실 세계의 문제를 코드로 옮길 때 복잡한 변환 과정 없이 자연스럽게 이어진다는 뜻입니다.
    - 객체 지향에서는 현실의 개념을 객체로 모델링하기 때문에 이 차이가 줄어들게 됩니다.
    
- 이번 장 정리

> 코드는 도메인의 개념적인 분류 체계가 아니라 객체의 행동과 변경에 영향을 받는다.
> 
> 
> 그리고 분석 모델, 설계 모델, 구현 모델 사이에 어떤 차이점도 존재하지 않는다. 
> 
> 이것들은 모두 행동과 변경 이라는 요소에 영향을 받으며 전체 개발 주기 동안 동일한 모양을 지녀야 한다. 
>
