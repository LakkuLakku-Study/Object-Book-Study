# (1) 타입

- 상속의 2가지 용도
    - **(1) 타입 계층을 구현**
        - 타입 계층의 관점에서
            - 부모 클래스 → 일반적인 개념을 구현 → “일반화”
            - 자식 클래스 →  특수한 개념을 구현 → “ 특수화“
        - 특징
            - 재사용하기 위해 상속을 사용하느 ㄴ것과 달리 타입 계층을 목표로 사용한다면 **다형적으로 동작하는 객체들의 관계**에 기반해 확장 가능하고 유연한 설계를 얻을 수 있다.
    - (2) 코드 재사용
        - 부모 클래스의 코드를 재사용
        - 상속으로 애플리케이션의 기능을 확장
        - 단점 : 부모와의 강한 결합으로 변경 어려울 수 있음

> 객체 지향 프로그래밍과 객체 기반 프로그래밍
> 
> 
> 둘 다 상태와 행동을 캡슐화한 객체를 조합
> 
> - 객체 지향 → 상속과 다형성 지원
> - 객체 기반 → 상속과 다형성 지원 안함
>     - 클래스 없이 오직 객체만을 사용하는 프로그래밍 방식 ex) 클래스가 존재하지 않은 자바 스크립트
>     

- 타입의 의미
    - (1) 개념적 타입
    - (2) 프로그래밍 언어 관점 타입
    

## 1) 개념 관점의 타입

- 타입
    - “세상의 사물의 종류”
    - 타입은 사물을 분류하기 위한 틀로 사용
    - 어떤 대상이 타입으로 분류될 때 그 대상을 “타입의 인스턴스”라고 부른다.
        - ex) 타입 → 프로그래밍 언어
            - 인스턴스 → C, Python, Java
- 타입의 구성요소
    - **심볼(symbol)**
        - 타입에 이름을 붙인 것입니다.
        - ex) 프로그래밍 언어
    - **내연(intension)**
        - 타입의 정의
        - 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다.
        - 일반적으로 타입에 속하는 객체들이 공유하는 **속성과 행동의 집합**이 내연을 구성합니다.
    - **외연(extension)**
        - 타입에 속하는 객체들의 집합입니다.
        - ex) 프로그래밍 언어의 경우 C, Python, Java 집합이 외연을 구성한다.

## 2) 프로그래밍 언어의 관점의 타입

- 프로그래밍 언어 관점에서 타입은 비트 묶음에 **`의미를 부여하기 위해 정의된 제약과 규칙`**
    - 연속적인 비트에 애플리케이션을 통해 제약과 의미가 부여된다.
- 프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용
    - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
        - ex) “+” 연산자의 경우 자바는 문자 타입과 원시형 숫자 이외에는 사용할 수 없다.
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
        - ex) 문자열일 경우 “+이면 문자열로 합치기, int라면 두 수를 합하기
- 프로그래밍 언어 관점에서 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용

## 객체지향 패러다임 관점의 타입

- 타입을 2가지로 정의 가능
    1. 개념 관점에서 타입이란 **공통의 특징을 공유**하는 대상들의 분류
    2. 프로그래밍 언어 관점의 타입이란 **동일한 오퍼레이션을 적용**할 수 있는 인스턴스들의 집합
- 두 타입의 정의를 **객체지향 패러다임의 관점**에서 조합해 보면 다음과 같습니다.
    - **`프로그래밍 언어의 관점`**에서 타입은 **`호출 가능한 오퍼레이션의 집합`**을 정의
        - 객체지향에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미합니다.
            
            ⇒ 따라서 객체의 타입이란 객체가 수신할 수 있는 **`메시지의 종류를 정의`**
            
            - 메시지 집합=⇒ 객체의 퍼블릭 인터페이스 → 객체지향에서 타입을 정의하는 것은 **객체의 퍼블릭 인터페이스를 정의**하는 것
    - **`개념 관점에서 타입은`** 공통 특성을 가진 객체들을 분류
        - 공통 특성 ?
            - 동일한 특성 → 동일한 퍼블릭 인터페이스 → 동일한 타입으로 묶을 수 있다.
- 결국 따라서, 객체지향 관점에서 타입이란 ?
    - 객체의 **퍼블릭 인터페이스**는 그 객체의 타입을 결정하며, 동일한 퍼블릭 인터페이스를 가진 객체들은 같은 타입으로 분류됩니다.
    
    ⇒ 따라서 객체지향 관점의 타입 의미를 봤을 때 객체에게 중요한 것은 속성이 아닌 **행동**임
    

# (2) 타입 계층

## 타입 사이의 포함 관계

!https://blog.kakaocdn.net/dn/BMElD/btsyglRIFwv/O0btr3gvTLkN3v8BKrkOX0/img.png

- 타입 간의 포함관계를 집합의 관점에서 이해
    - 수학에서 집합은 다른 집합을 포함할 수 있음 → 타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능
    - 타입 안에 포함된 객체들을 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 됨
        - ex) 프로그래밍 언어  → 객체 지향 → (더 세부적으로 묶은 )클래스 기반
    - 더 세분화된 타입의 집합이 다른 타입의 부분집합으로 포함될 수 있기 때문에 동일한 인스턴스가 여러 타입으로 분류될 가능
- 포함하는 타입은 인스턴스의 수가 더 많으며, 외연(범위) 관점에서는 더 크고 내연(내용) 관점에서는 더 일반적
    - 반면, 포함되는 타입은 외연 관점에서는 더 작고 내연 관점에서는 더 특수
    - ex) 프로그래밍 언어 타입은 객체 지향 언어 타입보다 “더 일반적”이고 객체 지향 언어 타입은 클래스 기반 언어 타입보다 일반적
    - ⇒ 이것은 포함 관계로 연결된 타입 사이에 개념적으로 일반화와 특수화 관계를 가진 계층으로 표현할 수 있다.
- 일반화와 특수화 관계를 가진 계층으로 표현 가능
    - 일반적인 타입을 더 위에, 더 특수하면 아래쪽에 배치
    

!https://blog.kakaocdn.net/dn/CudhX/btsylZAlAZv/NmY0upMlok0IqfO7nU2KU1/img.png

- 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 **슈퍼타입(supertype)**이라 부르고
- 더 특수한 타입을 **서브타입(subtype)**이라고 부름
    - 위 사진에서는 프로그래밍 언어 타입은 객체지향 언어 타입과 절차적 언어 타입의 슈퍼타입이고, 객체지향 언어 타입은 클래스 기반 언어 타입과 프로토타입 기반 언어 타입의 슈퍼타입입니다.
- 내연과 외연의 관점에서 일반화와 특수화를 정의
    - **객체의 정의**를 의미하는 내연 관점에서의 일반화 → 어떤 타입의 정의를 `좀 더 보편적이고 추상적으로` 만드는 과정
    - **집합을 의미**하는 외연 관점에서의 일반적인 타입의 인스턴스 집합은
        - → 특수한 타입의 인스턴스 집합을 포함하는 “슈퍼셋”
        - → 반대로, 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 “서브셋”
    
    > 즉, 일반화 → 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과
    > 
    > 
    > 특수화 → 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 행위의 결과 
    > 
- 슈퍼타입과 서브 타입
    - 슈퍼타입과 서브타입은 슈퍼셋, 서브셋으로부터 유래
    - 슈퍼타입 특징
        - 집합이 다른 집합의 모든 멤버를 포함한다.
        - 타입 정의가 다른 타입보다 좀 더 일반적임
    - 서브 타입 특징
        - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
        - 타입 정의가 다른 타입보다 좀 더 구체적

## 객체 지향 프로그래밍과 타입 계층

- **객체의 타입을 결정하는 것**
    - **“퍼블릭 인터페이스”**
- 일반적인 타입이란?
    - 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
- 특수한 타입이란?
    - 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스를 가지는 타입을 의미
- **퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입**
    - 슈퍼타입
        - 서브타입이 정의한 퍼블릭 인터페이스를 일반화 → 상대적으로 범용적이고 넓은 의미로 정의
    - 서브 타입
        - 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 → 상대적으로 구체적이고 좁은 의미로 정의
    - 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 **더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입**
    - 서브타입의 인스턴스 집합은 **슈퍼타입의 인스턴스 집합의 “부분 집합”**이기 때문에 더 특수한 퍼블릭 인터페이스를 가지는 객체들은 동시에 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 집합에 포함된다.
        - **“서브 타입의 인스턴스는 슈퍼 타입의 인스턴스로 간주될 수 있다.”**

# (3) 서브 클래싱과 서브 타이핑

- 타입을 구현하는 방법 → 클래스
- 타입 계층을 구현하는 방법 → 상속
    - 슈퍼타입 → 부모 클래스
    - 서브 타입 → 자식 클래스

## 언제 상속을 사용해야하는가?

- 타입 계층을 위해 올바르게 상속을 사용했다고 말할 수 있는 질문 2가지
    - (1) 상속 관계가 is-a 관계를 모델링?
        - 어휘적으로 “타입 S는 타입 T다”라고 말할 수 있어야 한다.
    - (2) 클라이언트 입장에서 부모 클래스 타입으로 자식 클래스를 사용해도 무방? ( 이 질문에 초점을 더 맞추면 좋다)
        - 사용하는 클라이언트 입장에서 부모 자식 차이를 모르고 있어야 그 둘 사이의 행동 호환성을 가질 수 있다.

## is-a 관계

- 이 관계는 직관적이고 명쾌하지 않다.
- 예를 들어, 펭귄은 새이다. 하지만 새의 속성인 “날다”(행위)를 만족하지 못한다.
    - 그렇기 떄문에 펭귄은 새의 “서브 타입이 될 수 없다”
    - 하지만 “날다”라는 행위가 없다면 서브 타입이 될 수 있다.
- 따라서, 행동의 문맥에 따라 타입 계층의 의미가 달라질 수 있다.
    - 즉, is-a관계를 만족해도 행동 호환성이 더 중요하다.

## 행동 호환성

- is-a 관계, 즉 개념적으로 연관이 있더다로 날다와 같이 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.
- 이떄, 행동 호환성을 만족할 때 상속 관계로 묶어야 하는데 이때, 행동이 호환된다는 것은 클라이언트의 관점에서 두 타입이 동일하게 행동할 것이라고 기대하는 것이다.
- 그렇기 떄문에 행동 호환성을 따지기 위해 그 타입 계층이 사용될 문맥을 이애하는 게 중요하다
- 그렇다면!
    - 펭귄은 비록 날지 못하기 때문에 펭귄이 새의 타입이 된다면 새에서 기대하는 “날다”의 속성을 하지 못하므로 문제가 된다. 하지만 펭귄은 새로 분류되기 때문에 상속관계로 그대로 두고 싶다면 3가지 방법이 있다.
        - (1) 펭귄의 fly 메서드를 오버라이딩해서 내부 구현을 비워두기 (날지 못한다를 구현, 이 메서드를 호출해도 아무 일도 일어나지 않는다)
            
            ```java
            class Penguin extends Bird{
            
            @Override
            public void fly(){
            	}
            }
            ```
            
            - 하지만 클라이언트 입장에서는 날다를 기대하고 메시지를 전송했기 때문에 클라이언트의 기대를 만족시키지 못한다는 점으로 인해 올바른 설계라고 말할 수 없다.
        - (2) 오버라이딩에서 예외를 던진다.
            
            ```java
            class Penguin extends Bird{
            
            @Override
            public void fly(){
            	throw new UnsupportedOperationException();
            	}
            }
            ```
            
            - 하지만 이 경우도 마찬가지고 클라이언트는 날다의 동작을 기대하고 던졌는데 기대를 이루지 못한 것이므로 올바른 설계가 아님
        - (3) 펭귄이 아닐 경우에만 fly 메서드를 전송할 수 있게 한다.
            
            ```java
            public void flyBird(Bird bird){
            	if(!(bird instance of Penguin)){
            		bird.fly();
            	}
            	}
            ```
            
            - 하지만 펭귄 이외에 또 다른 날 수 없는 새가 추가 된다면 또 이 if절을 변경해야할 것이다.
                - 즉, 구체 클래스에 대한 결합도를 높이고 변경 시 수정을 요구하기 때문에 개방 폐쇄 원칙을 위반한다.

## 클라이언트의 기대에 따라 계층 분리하기

- 위의 3가지 방법은 행동 호환성을 만족시키지만 클라이언트의 기대를 충족시키지 못한다.
    - 하지만 이를 1) 행동 호환성 만족 + 2) 클라이언트의 기대를 충족 모두 가능하도록 하는 방법 2가지
- 방법 1) “클라이언트의 기대에 맞게 상속 계층을 분리”한다면
    - 방법
        
        !https://blog.kakaocdn.net/dn/bev3do/btsywkRoDhU/I9f9S2rJymbRlWpzzBn6qK/img.png
        
        - flyBird 메서드는 파라미터로 전달되는 모든 새가 날 수 있다고 가정하기 때문에 flyBird 메서드와 협력하는 모든 객체는 fly 메시지에 대해 올바르게 응답할 수 있어야 한다.
            - → 펭귄의 인스턴스는 flyBird 메서드에 전달돼서는 안된다.
        - 펭귄과 협력하는 클라이언트는 날 수 없는 새와 협력할 것이라고 가정
            - → 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리
        
        ```java
        public class Bird{
         ...
         // 그냥 새
         }
         
         
         // 날 수 있는 새 -> flyingBird 타입을 통해 날 수 있는 새만 인자로 전달돼야 한다는 사실을 코드에 명시
         public class FlyingBird extends Bird{
        		public void fly(){}
        		
         }
         
          public class Penguin extends Bird{
        		// 
        		
         }
        ```
        
        - 클라이언트에서 사용
            
            ```java
            public void flyBird(FlyingBird bird){
            	bird.fly();
            	}
            ```
            
- 방법 2) 클라이언트에 따라 인터페이스를 분리
    
    !https://blog.kakaocdn.net/dn/cvHZG3/btsyubAAzqF/642TYNW5v0GPKec07q9DM1/img.png
    
    - walk 오퍼레이션을 가진 인터페이스와 fly 오퍼레이션을 가진 인터페이스를 분리
        - 새와 펭귄은 자신이 “수행할 수 있는 인터페이스만 구현”
    - 만약, 펭귄이 새의 코드를 재사용해야하는 경우에는 상속이 아닌 합성을 사용하자
        - 상속을 사용한다면 펭귄의 퍼블릭 인터페이스에 fly 오퍼레이션이 추가되기 때문에 부적합
        - 새의 퍼블릭인터페이스를 통해 재사용 가능하다는 전제를 만족시키는 방향으로 수정하여 재사용하자
    - 클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 된다.
    - 인터페이스를 클라이언트의 기대에 따라 분리하여 변경에 의해 영향을 제어하는 ISP 원칙(인터페이스 분리 원칙) 만족
        - 비대한 인터페이스가 쪼개져 클라이언트는 자신이 실제로 호출하는 메서드에만 의존할 수 있게 되어 호출하지 않는 메서드에 대한 클라이언트의 의존성을 끊게 된다.
- 꼭 현실 세계의 요구사항을 반영하지 않아도 된다.
    - 펭귄이 새로 분류되기 때문에 이러한 상식에 맞게 하기 위해 FlyBird라는 클래스를 추가한 것이다. 하지만 구현 상 필요없는 것이라면 굳이 추가하지 않아도 된다.

## 서브 클래싱과 서브 타이핑

- 서브 클래싱과 서브 타이핑
    - 서브 클래싱
        - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
        - 부모 행동이 자식과 호환되지 않기 때문에 자식의 인스턴스가 부모 인스턴스를 대체 불가능
        - 이를 구현 상속, 클래스 상속이라고도 부름
    - 서브 타이핑
        - 타입 계층을 구성하기 위해 상속 사용
        - 자식과 부모의 행동이 호환 가능 → 서로 대체 가능
        - 이때 부모 클래스는 자식클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브 타입이 된다.
        - 인터페이스 상속이라고도 부른다.
            - 정의할 때는 슈퍼타입으로 정의하고 런타임에 서브 타입의 객체로 대체할 수 있다.
- 상속을 사용하는 2가지 목적
    - 서브 클래싱과 서브 타이핑을 나누는 목적 == “ 상속을 사용하는 목적 “
        - 서브 클래싱 → 부모 클래스의 코드를 재사용 목적
        - 서브 타이핑 → 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 목적
- 슈퍼타입과 서브 타입 사이의 관계에서 가장 중요한 것은 “퍼블릭 인터페이스”이다.
    - 슈퍼 타입 인스턴스를 요구하는 모든 곳에서 서브 타입의 인스턴스를 대신 사용하기 위해 만족해야하는 최소한의 조건은 **“서브 타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야하는 것”**
        - → 개념적으로 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것처럼 보이게 된다.
            - → 따라서 서브타이핑을 인터페이스 상속이라고 부르는 것임
            - (반대로 서브 클래싱은 내부 구현 자체를 상속 받는 것에 초점을 맞추기 때문에 구현 상속 또는 클래스 상속이라고 부른다)
- 서브 타이핑 관계가 유지되기 위해서 → 서브 타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.
    - 즉, **`행동 호환성`**을 만족시켜야 한다.
    - 이를 만족하는 상속 관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 한다. → 그러므로 행동 호환성은 부모 클래스에 대한 자식 클래스의 `대체 가능성`을 포함한다.
- 행동 호환성과 대체 가능성은 올바른 상속 관계를 구축하기 위해 따라야할 지침
    - 행동 호환성과 대체 가능성
        
        ### 행동 호환성 (Behavioral Compatibility)
        
        행동 호환성은 두 객체 또는 클래스가 **동일한 인터페이스와 행동을 제공**하여 서로 교체하더라도 프로그램의 기능적 측면에서 문제가 없음을 의미합니다. 이는 주로 메서드의 시그니처, 반환 값, 예외 처리 등의 **외부적으로 관찰 가능한 행동**이 일치함을 강조합니다.
        
        ### 대체 가능성 (Substitutability)
        
        대체 가능성은 **리스코프 치환 원칙(Liskov Substitution Principle, LSP)**에 근거한 개념으로, **상위 타입의 객체를 하위 타입의 객체로 교체하더라도 프로그램의 정확성이 유지되어야 함**을 의미합니다. 이는 단순한 행동 호환성을 넘어, **객체의 의미론적 일관성**과 **시스템의 안정성**까지 고려합니다.
        
        ### 둘의 관계
        
        - **포괄성**: 행동 호환성은 대체 가능성을 위한 **필요 조건**이지만 **충분 조건은 아닙니다**. 즉, 행동 호환성이 있어도 대체 가능성이 항상 보장되는 것은 아닙니다.
        - **의미론적 차이**: 행동 호환성은 주로 **구문적 일치**에 초점을 맞추는 반면, 대체 가능성은 **의미론적 일치**와 **프로그램의 전체적인 안정성**을 고려합니다.
        - **원칙 적용**: 대체 가능성을 만족하려면 행동 호환성 외에도 **사전 조건은 강화되지 않고, 사후 조건은 약화되지 않아야** 합니다.
        
        ### 결론
        
        - **행동 호환성**은 대체 가능성을 달성하기 위한 중요한 요소이지만, **대체 가능성**은 그 이상의 **엄격한 조건**을 요구합니다.
        - 따라서, 두 개념은 **관련되어 있지만 동일하지 않으며**, 대체 가능성을 확보하기 위해서는 행동 호환성뿐만 아니라 객체의 **의미론적 일관성**과 **프로그램의 안정성**까지 고려해야 합니다.

# (4) 리스코프 치환 원칙

- 리스코프 치환 원칙
    - “서브 타입은 그것에 기반 타입에 대해 대체 가능”
    - 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다.
    - 즉, 행동 호환성을 설계 원칙으로 정리한 것이다.
- 위반 예시
    - 펭귄과 새의 관계
    - 정사각형과 직사각형의 관계
        - 정사각형은 직사각형일수도 있고 아닐 수도 있다.
        - 정사각형은 직사각형의 정의와 달리 너비와 높이가 동일해야한다는 제약 조건이 있으므로 이를 보장하기 위한 메서드가 있다.
        - 직사각형의 자식 클래스로 선언한다면 정사각형을 직사각형 타입으로 업캐스팅할 수 있는데 이때, 직사각형은 너비와 높이가 다를 수도 있다고 가정하기 때문에 문제가 될 수 있다.
        - 즉, 부모 대신 자식 클래스를 사용할 수 없기 때문에 리스코프 치환 원칙을 위반하며 서브 타이핑 관계가 아니다.
        - 단순히 재사용하기 때문에 서브 클래스 관계라고 할 수 있다.

## 클라이언트와 대체 가능성

- 정사각형이 직사각형을 대체할 수 없는 이유는 “클라이언트 입장에서 정사각형은 너비와 높이가 같다는 가정을 가진 것이고 직사각형은 다를 수 있다고 가정하기 때문에 둘은  다르기 때문”
- Stack과 Vector 관계도 마찬가지로 대체할 수 없다. (상속 관계라해도 클라이언트 입장에서 둘은 기대하는 바가 다르기 때문)
    - 클라이언트 입장에선 Stack은 임의의 위치에서 조회할 수 없다고 하는데
    - Vector는 임의의 위치에서 조회하거나 요소를 추출할 것이기 때문이다.

<aside>
💡

대체 가능성을 결정하는 것은 “클라이언트”이다. 

</aside>

## is-a 관계 다시 보기

- 단순히 어휘적으로 is-a 관계이고 부모와 자식간의 행동 호환성이 없고 대체 불가능하다면 is-a 관계가 아니다.
- 클라이언트 관점에서 is-a관계일 때만이 참이다.
    - 즉, 객체의 속성이 아닌 객체의 행동이 중요하다.
    - 속성 측면만 고려한다면 새와 펭귄의 관계가 is-a관계가 될 수 있는 거처럼 보인다. 하지만 행동을 고려한다면 둘은 대체 불가능하므로 is-a 관계가 될 수 없다는 것을 알 수 있게 된다. 즉, 객체의 행동이 더 중요하다.

## 리스코프 치환 원칙은 유연한 설계의 기반이다.

- 리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드 라인을 제공한다.
    - 새로운 자식 클래스를 추가하더라도 클라이언트의 입장에서 동일하게 행동하기만 한다면, 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.
    - 즉, 클라이언트의 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면, 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.
- 즉, 리스코프 치환은 유연하면서 확장성이 높다.
- 의존성 역전 원칙, 리스코프 치환원칙, 개방-폐쇄 원칙 3개 다 만족하는 예시
    - 의존성 역전 원칙
        - 구체 클래스에서  Movie(상위 수준의 모듈)와 OverlappedDiscountPolicy (하위 수준의 모듈)모두 추상클래스인 DiscountPolicy에 의존한다.
    - 리스코프 치환
        - DiscountPolicy와 협력하는 Movie의 관점에서 하위 수준의 모듈인 OverlappedDiscountPolicy 와 협력해도 문제가 없다.
    - 개방 폐쇄
        - 중복 할인 정책이라는 새로운 기능을 추가하기 위해 DisocuntPolicy의 자식 클래스인 OverlappedDiscountPolicy 를 추가하더라도 Movie에 영향이 안감

## 타입 계층과 리스코프 치환 원칙

- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나이다.
    - 동적 언어의 경우에는 상속을 하지 않고 서브 타이핑 관계를 구현할 수 있다.
- 방법은 중요하지 않고 “클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브 타입에게도 적용돼야 한다는 것이다”

# (5) 계약에 의한 설계와 서브 타이핑

- 의문점
    - 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있다는 것은 무엇을 의미하는가?
    - 클라이언트 관점에서 자식 클래스가 부모 클래스의 행동을 보존한다는 것은 무엇을 의미하는가?
- 계약에 의한 설계
    - **계약**이란, 클라이언트와 슈퍼타입(또는 서브타입) 사이에 서로 지켜야 할 약속을 정의하는 개념입니다.
    - `사전 조건(Precondition)`과 `사후 조건(Postcondition)`을 통해 이 계약을 구체적으로 정의합니다.
        - 사전 조건은 클라이언트가 협력 조건을 잘 맞춰 전달했는지 확인
        - 사후 조건은 나의 결과가 다시 클라이언트에게 맞는 값인지 확인
    - 3가지 요소로 구성
        - 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 사전 조건
        - 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 사후 조건
        - 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 클래스의 불변식
- 리스코프 치환원칙은 어떤 타입이 서브 타입이 되기 위해서는 슈퍼타입의 인스턴스와 협력하는 클라이언트 고나점에서 서브 타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것
    - **계약에 의한 설계를 사용하면 리스코프 치환 원칙이 “강제하는 조건”을 계약의 개념을 이용해 좀 더 명확하게 설명할 수 있다.**
    - **서브타입이 슈퍼타입의 계약(사전/사후 조건)을 준수하면, 리스코프 치환 원칙이 자동으로 만족**됩니다.
        - 반대로, 서브타입이 이 계약을 어기면, 리스코프 치환 원칙이 깨지기 때문에 계약에 의한 설계를 사용하면 좀 더 명확하게 설명 가능하다.
        
- 즉, 리스코프 치환원칙과 계약에 의한 설계 사이의 관계를 한 마디로 한다면,
    - “서브타입이 리스코프 치환 원칙을 만족시키기 위해서 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야한다”
- 이해를 돕기 위해 영화 예매 시스템에서 `DiscountPolicy`와 협력하는 `Movie` 클래스를 예로 들어보자
    - **`Movie`**
        
        ```java
        public class Movie {
          ...
          public Money calculateMovieFee(Screening screening) {
            return fee.minus(discountPolicy.calculateDiscountAmount(screening));
          }
        }
        ```
        
        - `Movie`는 `DiscountPolicy`의 인스턴스에게 `calculateDiscountAmount` 메시지를 전송하는 클라이언트다.
    - `DiscountPolicy`
        - `Movie`의 메시지를 수신한 후 할인 가격을 계산해서 반환한다
        
        ```java
        public abstract class DiscountPolicy {
          public Money calculateDiscountAmount(Screening screening) {
            for(DiscountCondition each : conditions) {
              if (each.isSatisfiedBy(Screening)) {
                return getDiscountAmount(screening);
              }
            }
        
            return screening.getMovieFee();
          }
        
          abstract protected Money getDiscountAmount(Screening screening);
        }
        ```
        

- 계약에 의한 설계에 따르면 협력하는 클라이언트와 슈퍼타입의 인스턴스 사이에는 어떤 계약이 맺어져 있다.
    - 클라이언트와 슈퍼타입은 이 계약을 준수할 때만 정상적으로 협력할 수 있음
    
    ```java
    DiscountPolicy는 할인 금액을 반환해야 하며, 반환 값은 0 이상이어야 합니다.
    Movie는 올바른 Screening 객체를 전달해야 하며, null을 전달하면 안 됩니다.
    ```
    
- 클라이언트 입장에서는 서브타입은 슈퍼타입의 한 종류여야한다.
    - 상속을 하면 모두가 서브타입이 되는 것이 아니다. 단순히 재사용하기 위해 사용했다면 서브 클래스가 되는 것이다.
    - 이에 따라 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은 **클라이언트가 슈퍼타입과 맺은 계약을 서브타입이 준수하는 것 뿐**
- Movie와 DiscountPolicy 코드 사이에는 암묵적인 사전조건과 사후조건이 존재
    - 사전 조건
        - `DiscountPolicy`의 `calculateDiscountAmount` 메서드는 인자로 전달된 `screening`이 `null`인지 여부를 확인하지 않음
        - 하지만 `screening`에 `null`이 전달된다면 `screening.getMovieFee()`가 실행될 때 `NullPointerException` 예외가 던져질 것
        - 단정문을 통해 사전조건 표현 가능
            
            ```java
            assert screening != null && screening.getStartTime().isAfter(LocalDateTime.now())
            ```
            
    - 사후 조건
        - `Movie`의 `calcualationMovieFee` 메서드를 살펴보면 `DiscountPolicy`의 `calculationDiscountAmount` 메서드의 반환값은 항상 `null`이 아니어야 한다.
        - 추가로 반환되는 값은 청구되는 요금이기 때문에 0원보다 커야 한다
            
            ```java
            assert amount != null && amount.isGreaterThanOrEqual(Money.ZERO);
            ```
            
    - 사전 조건과 사후 조건을 추가한 버전
        
        ```java
        public abstract class DiscountPolicy {
          public Money calculateDiscountAmount(Screening screening) {
            // 사전 조건 
            checkPrecondition(screening);
        
            Money amount = Money.ZERO;
            for(DiscountCondition each : conditions) {
              if (each.isSatisfiedBy(Screening)) {
                amount = getDiscountAmount(screening);
                checkPostcondition(amount);
                return amount;
              }
            }
        
            amount = screening.getMovieFee();
            // 사후 조건 
            checkPostcondition(amount);
            return amount;
          }
        
        // 사전조건 
          protected void checkPrecondition(Screening screening) {
            assert screening != null && screening.getStartTime().isAfter(LocalDateTime.now());
          }
        
        // 사후 조건 
          protected void checkPostcondition(Money amount) {
            assert amount != null && amount.isGreaterThanOrEqual(Money.ZERO);
          }
          abstract protected Money getDiscountAmount(Screening screening);
        }
        ```
        
        - Movie는 DiscountPolicy의 사전 조건을 만족시키는 책임을 가지며, 적절하지 않은 Screening 객체를 전달하면 예외를 발생시킵니다.
        
        ```java
        public class Movie {
          ...
          // calculateDiscountAmount 메서드가 정의한 사전 조건을 만족시키는 것은 Movie의 책임이다.
          // 따라서 사전 조건을 위반하는 Screening을 전달해서는 안된다. 
          public Money calculateMovieFee(Screening screening) {
            if (screening == null || screening.getStartTime().isBefore(LocalDateTime.now())) {
              throw new InvalidScreeningException();
            }
            return fee.minus(discountPolicy.calculateDiscountAmount(screening));
          }
        }
        ```
        

## 서브 타입과 계약

- 계약의 관점에서 상속이 초래하는 가장 큰 문제
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다.
    
    > ⇒  **“서브 타입에 더 강력한 사전조건을 정의할 수 없다. “**
    > 
    > - 만약, DiscountPolicy 보다 더 강력한 제약을 가진 BrokenDiscountPolicy를 만든다면 클라이언트 입장에서는 DiscountPolicy만 알기 때문에 협력이 불가능하다. (즉, 서브타입이 아니다. )
    >     - a조건만 맞는 것이라면 얼마든지 Movie와 협력할 것이라고 생각했는데 갑자기 a조건뿐만 아니라 b조건까지 만족하라고 하니 빡빡해졌다.
    >         - 클라이언트는 a조건만 맞는 너그러는 애만 알고 있기 때문에 빡빡한 애랑은 협력을 할 수 없다.
    >     - 컴파일러는 제약없이 DiscountPolicy로 업캐스팅하지만 동작은 실패할 것이다.
    >     
    >     ```java
    >     public class BrokenDiscountPolicy extends DiscountPolicy {
    >     
    >         public BrokenDiscountPolicy(DiscountCondition... conditions) {
    >             super(conditions);
    >         }
    >     
    >         @Override
    >         public Money calculateDiscountAmount(Screening screening) {
    >             checkPrecondition(screening);                 // 기존의 사전조건
    >             checkStrongerPrecondition(screening);         // 더 강력한 사전조건
    >     
    >             Money amount = screening.getMovieFee();
    >             checkPostcondition(amount);                   // 기존의 사후조건
    >     
    >             return amount;
    >         }
    >     
    >         private void checkStrongerPrecondition(Screening screening) {
    >             assert screening.getEndTime().toLocalTime()
    >                     .isBefore(LocalTime.MIDNIGHT);
    >         }
    >     
    >         @Override
    >         protected Money getDiscountAmount(Screening screening) {
    >             return Money.ZERO;
    >         }
    >     }
    >     ```
    >     
    
    > ⇒ **서브타입에 슈퍼타입과 같거나 더 약한 사후조건을 정의할 수 있다**
    > 
    > 
    > ```java
    > public class BrokenDiscountPolicy extends DiscountPolicy {
    > 
    >     public BrokenDiscountPolicy(DiscountCondition... conditions) {
    >         super(conditions);
    >     }
    > 
    >     @Override
    >     public Money calculateDiscountAmount(Screening screening) {
    >       //  checkPrecondition(screening);                 // 기존의 사전조건 제거
    > 
    >         Money amount = screening.getMovieFee();
    >         checkPostcondition(amount);                   // 기존의 사후조건
    > 
    >         return amount;
    >     }
    > ```
    > 
    > - BrokenDiscountPolicy에서 사전 조건을 제거했지만 Movie는 DiscountPolicy가 정의한 사전조건을 만족시키기 위해 null이 아니며 현재 시간 이후에 시작하는 Screening을 전달한다는 것을 보장한다.
    >     - 클라이언트는 이미 자신의 의무를 충실히 수행하고 있기 때문에 이 조건을 체크하지 않는 것이 기존 협력에 영향도 미치지 않는다.

> ⇒ **서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다**
> 
> 
> ```java
> public class BrokenDiscountPolicy extends DiscountPolicy {
> 
>     public BrokenDiscountPolicy(DiscountCondition... conditions) {
>         super(conditions);
>     }
> 
>     @Override
>     public Money calculateDiscountAmount(Screening screening) {
>        checkPrecondition(screening);                 // 기존의 사전조건 제거
> 
>         Money amount = screening.getMovieFee();
>         checkPostcondition(amount);                   // 기존의 사후조건
> 				checkStrongcondition(amount);    // 더 강한 사후 조건 
>         return amount;
>     }
> ```
> 
> - Movie는 DiscountPolicy의 사후조건만 알고 있기 때문에 0보다 크면 정상적으로 수행된다고 생각하기 때문에 협력할 때 문제 없음

> **⇒ 서브타입에 슈퍼타입과 더 약한 사후조건을 정의할 수 없다**
> 
> 
> ```java
> public class BrokenDiscountPolicy extends DiscountPolicy {
> 
>     public BrokenDiscountPolicy(DiscountCondition... conditions) {
>         super(conditions);
>     }
> 
>     @Override
>     public Money calculateDiscountAmount(Screening screening) {
>         checkPrecondition(screening);                 // 기존의 사전조건 제거
> 
>         Money amount = screening.getMovieFee();
>     //    checkPostcondition(amount);                   // 기존의 사후조건 제거 
> 					checkWeakerPostcondition(amount);    // 더 약한 사후 조건 
>         return amount;
>     }
> ```
> 
> - 변경된 코드에서 요금 계산 결과가 마이너스라도 그대로 반환한다.
> - Movie는 DiscountPolicy의 인스턴스라고 생각하고 이들의 자식들과 협력하는데, 이때, 반환된 금액이 0보다는 크다고 믿기 때문에 0보다 작은 것들이 조건을 통해 걸러내지 못한다면 원활한 협력 불가능
