- “상속”과 “합성” 공통점
    - 객체 지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법
- 상속과 합성의 차이점
    - 상속
        - **부모 클래스와 자식 클래스**를 연결해서 부모 클래스를 재사용
        - 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결된다.
        - is-a 관계
        - 재사용 방법
            - 부모 클래스와 다른 부분만 추가 혹은 재정의하여 확장
            - 부모 클래스의 내부 구현에 대해 상세하게 알아야 한다. → 결합도 높아짐
        - 클래스와의 정적인 관계 → 코드 작성 시점에 상속 관계를 결정해버리면 변경 불가
    - 합성
        - 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 **부분 객체의 코드**를 재사용
        - 두 객체 사이의 의존성은 런타임에 해결된다.
        - has - a 관계
        - 재사용 방법
            - 객체의 구현이 아닌 퍼블릭 인터페이스에 의존
            - 변경의 영향을 받지 않음
        - 클래스와의 동적인 관계 → 실행시점에 동적으로 변할 수 있음
            - → 코드를 재사용하기 위해서는 상속보다 합성을 이용하는 것이 더 좋은 방법
- 상속과 합성은 재사용의 대상이 다르다.
    - 상속 → 부모 클래스 안에 구현된 코드 자체를 재사용 (화이트박스 재사용)
    - 합성 → 퍼블릭 클래스를 재사용 → 인터페이스에 대한 의존도 → 낮은 결합도 (블랙박스 재사용)

# (1) 상속을 합성으로 변경 (안전성)

- 코드 재사용을 위해 상속 남용시 3가지 문제점
    - (1) 불필요한 인터페이스 상속
        - 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
    - (2) 메서드 오버라이딩의 오작용
        - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
    - (3) 부모 클래스와 자식 클래스의 동시 수정 문제
        - 결합으로 인해 부모 클래스의 수정 시 자식 클래스도 수정해야함
- 합성으로 3가지 문제점을 해결할 수 있다.
    - 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.

- 문제점들을 상속 관계로 바꿔보자

### (1) 불필요한 인터페이스 상속 문제

- **문제점 : `java.util.Properties`**의 경우, 오직 String으로만 되어 있는 ****Key-Value쌍을 관리한다.
    - → Hashtable을 상속받기 때문에 이 클래스의 put을 사용할 수 있음 String 여부를 확인하여 체크하는 방법이 없기 때문에 String이외의 값이라도 저장할 수 있게 된다.
    - 합성 관계로 변경
        
        ```java
        public class Properties {
        // Hashtable와의 상속 관계 제거 후 인스턴스 변수로 포함
            private Hashtable<String, String> properties = new Hashtable <>();
        
            public String setProperty(String key, String value) {
                return properties.put(key, value);
            }
        
            public String getProperty(String key) {
                return properties.get(key);
            }
        }
        ```
        
        - Properties에서 정의한 오퍼레이션만 사용할 수 있다.
            - Hashtable의 오퍼레이션을 사용할 수 없게 되어 Properties 규칙을 어길 위험성은 사라진다.
            - 상속은 Hashtable의 내부 구현을 다 알 수 밖에 없었지만 Hashtable의 내부 구현에 대해 모르게 되었다.
- 문제점 : Stack도 Vector의 퍼블릭 인터페이스를 이용하면 get, add, remove를 사용할 수 있음
    - → 이것은 맨 마지막 위치에만 넣고 뺄 수 있는 Stack 규칙을 쉽게 위반하는 것임
    - 🪄합성 관계로 변경(뾰로롱!)
        
        ```java
        public class Stack<E> {
        // 원래 상속 관계 였던 것을 변수로 선언 -> 합성 관계 
            private Vector<E> elements = new Vector<>();
        
            public E push(E item) {
                elements.addElement(item);
                return item;
            }
        
            public E pop() {
                if (elements.isEmpty()) {
                    throw new EmptyStackException();
                }
                return elements.remove(elements.size() - 1);
            }
        }
        ```
        

### (2) 메서드 오버라이딩의 오작용 문제

- 문제점 : 자식에서 구현해놓은 것과 로직이 합쳐질 수 있다.
    - 🪄합성 관계로 변경(뾰로롱!)
        
        ```java
        public class InstrumentedHashSet<E>{
            private int addCount = 0;
            
            
            // 변수로 넣어 합성 관계로 
            private Set<E> set;
        
            public InstrumentedHashSet(Set<E> set) {
                this.set = set;
            }
        
            @Override
            public boolean add(E e) {
                addCount++;
                return set.add(e);
            }
        
            @Override
            public boolean addAll(Collection<? extends E> c) {
                addCount += c.size();
                return set.addAll(c);
            }
        ```
        
        - 앞에서 stack과 같은 케이스는 불필요한 오퍼레이션이 스며드는 것을 방지하기 위해서 합성 관계로 변경한 것이었지만, HashSet이 제공하는 퍼블릭 인터페이스는 그대로 사용해야한다.
            - 인터페이스를 사용하여 결합도를 제거하면서 퍼블릭 인터페이스는 그대로 사용하도록 변경
                - InstrumentedHashSet이 제공해야하는 모든 오퍼레이션은 Set 인터페이스에 정의되어 있음
                - Set 인터페이스를 실체화하면서 내부에 HashSet를 합성하면 구현 결합도 제거하면서 퍼블릭 인터페이스는 그대로 유지 가능
        
        ```java
        public class InstrumentedHashSet<E> implements Set<E> {
            private int addCount = 0;
            
            //HashSet합성 
            private Set<E> set;
        
            public InstrumentedHashSet(Set<E> set) {
                this.set = set;
            }
        
            @Override
            public boolean add(E e) {
                addCount++;
                return set.add(e);
            }
        
            @Override
            public boolean addAll(Collection<? extends E> c) {
                addCount += c.size();
                return set.addAll(c);
            }
        
            public int getAddCount() {
                return addCount;
            }
        
            @Override public boolean remove(Object o) {
                return set.remove(o);
            }
        
            @Override public void clear() {
                set.clear();
            }
        
            @Override public boolean equals(Object o) {
                return set.equals(o);
            }
        
            @Override public int hashCode() {
                return set.hashCode();
            }
        
            @Override public Spliterator<E> spliterator() {
                return set.spliterator();
            }
        
            @Override public int size() {
                return set.size();
            }
        
            @Override public boolean isEmpty() {
                return set.isEmpty();
            }
        
            @Override public boolean contains(Object o) {
                return set.contains(o);
            }
        
            @Override public Iterator<E> iterator() {
                return set.iterator();
            }
        
            @Override public Object[] toArray() {
                return set.toArray();
            }
        
            @Override public <T> T[] toArray(T[] a) {
                return set.toArray(a);
            }
        
            @Override public boolean containsAll(Collection<?> c) {
                return set.containsAll(c);
            }
        
            @Override public boolean retainAll(Collection<?> c) {
                return set.retainAll(c);
            }
        
            @Override public boolean removeAll(Collection<?> c) {
                return set.removeAll(c);
            }
        }
        ```
        
        - 포워딩 메서드
            - 인터페이스(Set)를 오버라이딩한 메서드 내에서 HashSet 인스턴스에게 동일한 메서드를 호출하는 방법
            - 기존 클래스의 인터페이스(Set)을 그대로 외부에 제공하면서 구현에 대한 결함없이 일부 작동 방식을 변경하고 싶을 때 사용

### (3) 부모 클래스와 자식 클래스의 동시 수정 문제

- 문제점 : 결합으로 인해 부모 클래스의 수정 시 자식 클래스도 수정해야함
    - 합성 관계로 변경하더라도 문제는 그대로이다.
        
        ```java
        public class PersonalPlaylist {
            private Playlist playlist = new Playlist();
        
            public void append(Song song) {
                playlist.append(song);
            }
        
            public void remove(Song song) {
                playlist.getTracks().remove(song);
                playlist.getSingers().remove(song.getSinger());
            }
        }
        ```
        
    - 그래도 상속보다는 합성 관계가 나음
        - → 부모의 변경 파급 효과를 내부로 캡슐화 가능
- 몽키 패치 (Monkey Patch)
    - 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장
        - 자바는 언어차원에서 지원해주지 않지만 AOP를 이용해 몽키 패치를 구현하고 있다.
        - Spring AOP를 사용하면 **실행 중에** 특정 메서드에 추가 기능을 삽입할 수 있으며, 이는 몽키 패치와 유사하게 런타임에 특정 메서드의 동작을 변경할 수 있도록 해줍니다.
    - AOP 예시
        - 적용 코드
            
            ```java
            package com.example.service;
            
            import org.springframework.stereotype.Service;
            
            @Service
            public class DataService {
                public void processData() {
                    System.out.println("Processing data...");
                    // 실제 처리 로직
                }
            }
            
            ```
            
        - AOP 코드
            
            ```java
            package com.example.aspect;
            
            import org.aspectj.lang.annotation.After;
            import org.aspectj.lang.annotation.Before;
            import org.aspectj.lang.annotation.Aspect;
            import org.springframework.stereotype.Component;
            
            @Aspect
            @Component
            public class DataServiceAspect {
            
                // 실행 전 로직
                @Before("execution(* com.example.service.DataService.processData(..))")
                public void beforeProcessData() {
                    System.out.println("Before processing data - Preprocessing steps...");
                }
            
                // 실행 후 로직
                @After("execution(* com.example.service.DataService.processData(..))")
                public void afterProcessData() {
                    System.out.println("After processing data - Postprocessing steps...");
                }
            }
            
            ```
            
        - 이제 `DataService`의 `processData()` 메서드를 호출하면 AOP에 의해 추가된 "Before"와 "After" 메시지가 출력됩니다.
            
            ```java
            Before processing data - Preprocessing steps...
            Processing data...
            After processing data - Postprocessing steps...
            ```
            
        - 여기서! 매번 의문이 들었던 부분을 확실히 확인하고 넘어갈 수 있었다.
            - AOP를 사용해 코드를 작성하고 컴파일한 후에는 변경된 동작이 고정되므로, 엄밀히 말해 *실제 런타임 중간에* 바뀌는 것은 아닌가?
            - 답변 : AOP는 기본적으로 코드의 원본을 수정하지 않고 프록시 객체를 생성하여 대상 메서드의 동작을 수정합니다. 이 점에서 원래의 코드가 수정된 것처럼 *외부적으로 보이게* 하며, 실제 호출 시점에만 영향을 주는 방식이기 때문에 제한적이나마 런타임에서의 동작 변화를 흉내낼 수 있습니다.
                - 리플렉션도 마찬가지로 미리 정의된 메서드를 호출하거나 필드 값을 변경할 수 있게 해주는 기술이지, *실제 코드 자체를 변형하거나 새로운 로직을 추가*하는 것은 아닙니다.

# (2) 상속으로 인한 조합의 폭발적인 증가 (유연성)

- 상속으로 인해 결합도가 높아지면 생기는 문제점
    - (1) 하나의 기능을 추가 혹은 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야한다. (**클래스 증가**)
    - (2) 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 **중복 코드**의 양이 늘어날 수 있다.

- 합성으로 상속으로 인해 발생하는 클래스의 증가와 중복 코드 해결 가능

### 기본 정책과 부가 정책 조합하기

- 핸드폰 요금제가 기본 정책과 부가 정책을 조합해서 나온다고 가정
    - 기본 정책
        - 일반 요금제
        - 심야 할인 요금제
    - 부가 정책
        - 세금 정책
        - 기본 요금 할인 정책
- 기본 정책
    - 가입자의 통화 정보를 기반으로 한다.
    - 따라서, 통화량을 기반으로 계산하는 일반 요금제와 심야 할인 요금제를 기본 정책으로 분류함
- 부가정책
    - 통화량과 무관하게 기본 정책에 선택적으로 추가할 수 있는 요금 방식
    - 특성
        - (1) 기본 정책의 계산 결과에 적용한다.
            - 일반 요금제 혹은 심야 할인 요금제 계산이 끝난 결과에 세금을 부과
        - (2) 선택적으로 적용 가능
            - 적용할 수도 있고 안할 수도 있다.
        - (3) 조합 가능
            - 1개의 부가 정책만 사용하는 것이 아니라 종류 모두 사용 가능
        - (4) 부가 정책은 임의의 순서로 적용 가능
            - 세금 정책 계산 후 기본 요금 할인 정책 계산을 하거나 반대의 순서도 가능
            
- 가능한 조합이 너무 많다. → 유연해야한다.

### 상속을 이용해서 기본 정책 구현하기

- 기본 정책
    - phone(추상 클래스)
        
        ```java
        public abstract class Phone {
            private List<Call> calls = new ArrayList<>();
        
            public Money calculateFee() {
                Money result = Money.ZERO;
        
                for(Call call : calls) {
                    result = result.plus(calculateCallFee(call));
                }
        
                return result;
            }
        
            abstract protected Money calculateCallFee(Call call);
        }
        ```
        
    - RegularPhone
        
        ```java
        public class RegularPhone extends Phone {
            private Money amount;
            private Duration seconds;
        
            public RegularPhone(Money amount, Duration seconds) {
                this.amount = amount;
                this.seconds = seconds;
            }
        
            @Override
            protected Money calculateCallFee(Call call) {
                return amount.times(call.getDuration().getSeconds() / seconds.getSeconds());
            }
        }
        ```
        
    - NightlyDiscountPhone
        
        ```java
        public class NightlyDiscountPhone extends Phone {
            private static final int LATE_NIGHT_HOUR = 22;
        
            private Money nightlyAmount;
            private Money regularAmount;
            private Duration seconds;
        
            public NightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds) {
                this.nightlyAmount = nightlyAmount;
                this.regularAmount = regularAmount;
                this.seconds = seconds;
            }
        
            @Override
            protected Money calculateCallFee(Call call) {
                if (call.getFrom().getHour() >= LATE_NIGHT_HOUR) {
                    return nightlyAmount.times(call.getDuration().getSeconds() / seconds.getSeconds());
                } else {
                    return regularAmount.times(call.getDuration().getSeconds() / seconds.getSeconds());
                }
            }
        }
        ```
        

### **기본 정책에 세금 정책 조합하기(1)**

- **기본 정책에 “세금 정책”**
    - **일반 요금제에 세금 정책을 조합**하기 위해 RegularPhone 클래스를 상속받은 TaxableRegularPhone 클래스를 추가한다.
        - calculateFee 메서드를 오버라이딩한 후 super 호출을 통해 부모 클래스의 calculateFee 메서드로 일반 요금제 규칙에 따라 계산된 요금에 세금을 더하여 반환한다.
            
            ```java
            public class TaxableRegularPhone extends RegularPhone {
                private double taxRate;
            
                public TaxableRegularPhone(Money amount, Duration seconds, double taxRate) {
                    //super 호출은 자식 클래스와 부모 클래스의 결합도가 높아진다.
                    super(amount, seconds);
                    this.taxRate = taxRate;
                }
            
                @Override
                public Money calculateFee() {
                    Money fee = super.calculateFee();
                    return fee.plus(fee.times(taxRate));
                }
            }
            ```
            
    
    - 하지만 결합도를 낮추기 위해 부모 클래스에 추상 메서드를 정의하여 자식 클래스가 부모 클래스의 메서드를 호출하지 않도록 한다.
        - 추상 클래스 수정
            
            ```java
            public abstract class Phone {
                private List<Call> calls = new ArrayList<>();
            
                public Money calculateFee() {
                    Money result = Money.ZERO;
            
                    for (Call call : calls) {
                        result = result.plus(calculateCallFee(call));
                    }
            
                    return afterCalculated(result);
                }
            
                protected abstract Money calculateCallFee(Call call);
                
                // 결합도를 낮추기 위해 추상 클래스에 정의 -> 자식 클래스에서 오버라이딩
            		// calculateFee 메서드에서 전체 요금을 계산한 후에 afterCalculated 메서드를 호출하여 전체 요금 계산 후 수행할 로직을 수행
                protected abstract Money afterCalculated(Money fee);
            }
            ```
            
        - RegularPhone, NightlyDiscountPhone은 요금을 수정할 필요가 없으므로 파라미터에서 전달된 요금을 그대로 반환하도록 구현한다.
            
            ```java
            public class RegularPhone extends Phone {
                private Money amount;
                private Duration seconds;
            
                public RegularPhone(Money amount, Duration seconds) {
                    this.amount = amount;
                    this.seconds = seconds;
                }
            
                @Override
                protected Money calculateCallFee(Call call) {
                    return amount.times((double) call.getDuration().getSeconds() / seconds.getSeconds());
                }
            
            // 그대로 반환
                @Override
                protected Money afterCalculated(Money fee) {
                    return fee;
                }
            }
            ```
            
            ```java
            public class NightlyDiscountPhone extends Phone {
            
                private static final int LATE_NIGHT_HOUR = 22;
            
                private Money nightlyAmount;
                private Money regularAmount;
                private Duration seconds;
            
                public NightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds) {
                    this.nightlyAmount = nightlyAmount;
                    this.regularAmount = regularAmount;
                    this.seconds = seconds;
                }
            
                @Override
                protected Money calculateCallFee(Call call) {
                    if (call.getFrom().getHour() >= LATE_NIGHT_HOUR) {
                        return nightlyAmount.times((double) call.getDuration().getSeconds() / seconds.getSeconds());
                    }
            
                    return regularAmount.times((double) call.getDuration().getSeconds() / seconds.getSeconds());
                }
            
                @Override
                protected Money afterCalculated(Money fee) {
                    return fee;
                }
            }
            ```
            
    - 개선점
        - 모든 자식들이 추상 메서드를 오버라이딩을 꼭 해야하므로 번거로움→ NightlyDiscountPhone, RegularPhone 둘다 동일한 로직의 함수로 구현했으므로 중복
            - → 추상 메서드에 **기본 구현을 함께 제공**하여 중복 코드를 제거할 수 있다. ( 훅 메서드 : 추상 메서드의 단점 해결 )
            
            ```java
            public abstract class Phone {
                private List<Call> calls = new ArrayList<>();
            
                public Money calculateFee() {
                    Money result = Money.ZERO;
            
                    for (Call call : calls) {
                        result = result.plus(calculateCallFee(call));
                    }
            
                    return afterCalculated(result);
                }
            
            // 중복 제거 
                protected Money afterCalculated(Money fee) {
                    return fee;
                }
                protected abstract Money calculateCallFee(Call call);
            }
            ```
            
            ```java
            public class RegularPhone extends Phone {
                private Money amount;
                private Duration seconds;
            
                public RegularPhone(Money amount, Duration seconds) {
                    this.amount = amount;
                    this.seconds = seconds;
                }
            
                @Override
                protected Money calculateCallFee(Call call) {
                    return amount.times((double) call.getDuration().getSeconds() / seconds.getSeconds());
                }
            }
            ```
            
            ```java
            public class NightlyDiscountPhone extends Phone {
            
                private static final int LATE_NIGHT_HOUR = 22;
            
                private Money nightlyAmount;
                private Money regularAmount;
                private Duration seconds;
            
                public NightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds) {
                    this.nightlyAmount = nightlyAmount;
                    this.regularAmount = regularAmount;
                    this.seconds = seconds;
                }
            
                @Override
                protected Money calculateCallFee(Call call) {
                    if (call.getFrom().getHour() >= LATE_NIGHT_HOUR) {
                        return nightlyAmount.times((double) call.getDuration().getSeconds() / seconds.getSeconds());
                    }
            
                    return regularAmount.times((double) call.getDuration().getSeconds() / seconds.getSeconds());
                }
            }
            ```
            
    - TaxableRegularPhone 클래스는 세금을 부과하는 부가정책이다. afterCalculated 메서드를 오버라이딩한 후 fee에 세금을 더해서 반환하도록 구현
        
        ```java
        public class TaxableRegularPhone extends RegularPhone {
            private double taxRate;
        
            public TaxableRegularPhone(Money amount, Duration seconds, double taxRate) {
                super(amount, seconds);
                this.taxRate = taxRate;
            }
        
            @Override
            protected Money afterCalculated(Money fee) {
                return fee.plus(fee.times(taxRate));
            }
        }
        ```
        
        ```java
        public class TaxableNightlyDiscountPhone extends NightlyDiscountPhone {
            private double taxRate;
        
            public TaxableNightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds, double taxRate) {
                super(nightlyAmount, regularAmount, seconds);
                this.taxRate = taxRate;
            }
        
            @Override
            protected Money afterCalculated(Money fee) {
                return fee.plus(fee.times(taxRate));
            }
        }
        ```
        

### **기본 정책에 세금 정책 조합하기(2)**

- **기본 정책에 “기본 요금 할인 정책”**
    - 고정된 금액 더 할인함
    - RegularPhone, NightlyDiscountPhone을 상속받는RateDiscountableRegularPhone, RateDiscountableNightlyDiscountPhone 클래스를 추가
    - RateDiscountableRegularPhone
        
        ```java
        public class RateDiscountableRegularPhone extends RegularPhone {
            private Money discountAmount;
        
            public RateDiscountableRegularPhone(Money amount, Duration seconds, Money discountAmount) {
                super(amount, seconds);
                this.discountAmount = discountAmount;
            }
        
            @Override
            protected Money afterCalculated(Money fee) {
                return fee.minus(discountAmount);
            }
        }
        ```
        
    - RateDiscountableNightlyDiscountPhone
        
        ```java
        public class RateDiscountableNightlyDiscountPhone extends NightlyDiscountPhone {
            private Money discountAmount;
        
            public RateDiscountableNightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds, Money discountAmount) {
                super(nightlyAmount, regularAmount, seconds);
                this.discountAmount = discountAmount;
            }
        
            @Override
            protected Money afterCalculated(Money fee) {
                return fee.minus(discountAmount);
            }
        }
        ```
        

- 완성된 조합 계층
    - 클래스가 하나의 조합 의미
        
        ![스크린샷 2024-11-13 오후 4.54.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/2d4379d8-b2ad-4cc2-9761-6ea4d943f464/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.54.54.png)
        

### 중복 코드의 덫에 걸리다.

- RateDiscountableRegularPhone, RateDiscountableNightlyDiscountPhone 클래스 사이의 중복 코드 발생 → 이는 여러 부가 정책 들을 조합할 때 문제가 생김
- 조건 중 세금 정책과 기본 요금 할인 정책을 함께 적용하는 것도 가능하고 반대의 순서도 가능하다.
    - 상속을 이용한 해결 방법은 모든 가능한 조합별로 자식 클래스를 추가하는 것이다.
    - 이를 구현하기 위해서 각각 자식 클래스로 또 만드는 것이다.
- 새로운 자식 TaxableAndDiscountableNightlyDiscountPhone
    - (1) 세금 정책 후 → 기본 할인 요금 계산
    
    ```java
    public class TaxableAndDiscountableRegularPhone extends TasxableRegularPhone {
        private Money discountAmount;
    
        public TaxableAndDiscountableNightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds,
              double taxRate, Money discountAmount) {
            super(nightlyAmount, regularAmount, seconds, taxRate);
            this.discountAmount = discountAmount;
        }
    
        @Override
        protected Money afterCalculated(Money fee) {
        // 부모 클래스인 TasxableRegularPhone의 afterCalculated를 호출 후 -> 기본 요금 할인 정책을 적용한다. 
            return super.afterCalculated(fee).minus(discountAmount);
        }
    }
    ```
    
- 순서 조합도 고려한 계층 관계
    
    ![스크린샷 2024-11-13 오후 5.03.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/be1e6d04-5f78-435f-abdf-ed88e8b13f82/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.03.20.png)
    
- 하지만 이렇게 된다면 복잡하며 새로운 정책 추가가 어렵다는 것이다.
    - 새로운 정책을 추가하기 위해 불필요하게 많은 수의 클래스를 상속 계층 안에 추가해야한다.
    - ex) FixedRatePhone 추가 시 가능한 조합들 수(5개나) 만큼 클래스를 만들어야 한다.
        
        ![스크린샷 2024-11-13 오후 5.05.53.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/db3dff1a-bad2-4fce-b0c1-b0a13068f4a5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.05.53.png)
        
        ⇒ “클래스 폭발” 문제 or “조합 폭발” 문제 
        
        - 이는 상속의 근본적인 한계
        - 컴파일 타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에 발생하는 문제
        - 해결 방법 : 상속을 포기
        

# (3) 합성 관계로 변경하기

- 상속 관계는 컴파일 타임에 관계가 고정되기 때문에 클래스 폭발 문제가 발생했으므로 이것을 런타임으로 변경하여 의존성을 자유롭게 변경하여 문제를 해결할 수 있다.
- 합성으로 컴파일 타임 의존성과 런타임 의존성을 다르게 만들 수 있어 유연하게 만들 수 있다.
    - 상속의 경우에는 조합의 결과를 개별 클래스 안으로 밀어 넣는 방법이지만,
    - 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법으로 사용하여 유연하다.
        - 고정하지 않고 기본 정책과 부가 정책을 독립적인 박스로 표현
- 물론, 컴파일 타임 의존성과 런타임 의존성이 멀수록 구현이 복잡하다는 단점이 있지만 (트레이드 오프 관계) 변경하기 편리한 설계를 만들기 위해 복잡성을 더하면 원래 설계보다 단순해진다.

### 기본 정책 합성하기

- 가장 먼저해야할 일 = 각 정책을 별도의 클래스로 구현
    - 핸드폰이라는 개념으로부터 요금 계산 방법이라는 개념을 분리하자
        - 기본정책과 부가 정책을 포괄하는 RatePolicy 인터페이스 추가
            
            ```java
            public interface RatePolicy {
            // 요금 계산
                Money calculateFee(Phone phone);
            }
            ```
            
    - 기본 정책을 구성하는 일반 요금제와 심야 할인 요금제의 중복 코드를 담을 추상 클래스를 추가
        
        ```java
        public abstract class BasicRatePolicy implements RatePolicy {
            @Override
            public Money calculateFee(Phone phone) {
                Money result = Money.ZERO;
        
                for(Call call : phone.getCalls()) {
                    result.plus(calculateCallFee(call));
                }
        
                return result;
            }
        
        // 자식 클래스에서 오버라이딩을 통해 자신만의 방식으로 구현가능 
            protected abstract Money calculateCallFee(Call call);
        }
        ```
        
        - 일반 요금제 ( BasicRatePolicy의 자식 클래스 )
            
            ```java
            public class RegularPolicy extends BasicRatePolicy {
                private Money amount;
                private Duration seconds;
            
                public RegularPolicy(Money amount, Duration seconds) {
                    this.amount = amount;
                    this.seconds = seconds;
                }
            
                @Override
                protected Money calculateCallFee(Call call) {
                    return amount.times(call.getDuration().getSeconds() / seconds.getSeconds());
                }
            }
            ```
            
        - 심야 할인 요금제 ( BasicRatePolicy의 자식 클래스 )
            
            ```java
            public class NightlyDiscountPolicy extends BasicRatePolicy {
                private static final int LATE_NIGHT_HOUR = 22;
            
                private Money nightlyAmount;
                private Money regularAmount;
                private Duration seconds;
            
                public NightlyDiscountPolicy(Money nightlyAmount, Money regularAmount, Duration seconds) {
                    this.nightlyAmount = nightlyAmount;
                    this.regularAmount = regularAmount;
                    this.seconds = seconds;
                }
            
                @Override
                protected Money calculateCallFee(Call call) {
                    if (call.getFrom().getHour() >= LATE_NIGHT_HOUR) {
                        return nightlyAmount.times(call.getDuration().getSeconds() / seconds.getSeconds());
                    }
            
                    return regularAmount.times(call.getDuration().getSeconds() / seconds.getSeconds());
                }
            }
            ```
            
    - 기본 정책을 이용해 요금을 계산할 수 있도록 Phone을 수정
        - RatePolicy 합성
            - 다양한 요금 정책과 협력해야하므로 정책 타입이 RatePolicy이다.
            - 컴파일 의존성을 구체적인 런타임 의존성으로 대체하기 위해 생성자를 통해 RatePolicy의 인스턴스에 대한 의존성을 주입받는다.
        
        ```java
        public class Phone {
        // Phone 내부에 RatePolicy에 대한 참조자가 포함돼 있다. 
        // 이것이 바로 합성이다.
        
        Phone은 생성자를 통해 RatePolicy의 인스턴스에 대한 의존성을 주입
            private RatePolicy ratePolicy;
            private List<Call> calls = new ArrayList<>();
        
            public Phone(RatePolicy ratePolicy) {
                this.ratePolicy = ratePolicy;
            }
        
            public List<Call> getCalls() {
                return Collections.unmodifiableList(calls);
            }
        
            public Money calculateFee() {
                return ratePolicy.calculateFee(this);
            }
        }
        ```
        
- 예를 들어, 일반 욕금 규칙에 따라 계산하기 위해서 Phone과 BasicRatePolicy 의 인스턴스인 RegularPolicy를
    
    ```java
    
    Phone phone = new Phone(new RegularPolicy(Money.wons(10), Duration.ofSeconds(10)));
    ```
    

![스크린샷 2024-11-13 오후 5.47.55.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/b6bbb555-3e88-4f0a-8301-312d5308c83a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.47.55.png)

### 부가 정책 사용하기

- 인스턴스 관계
    - 일반 요금제를 적용한 경우의 관계
        - [Phone] → (`calculateFee(phone)`) → [RegularPolicy]
    - 정책 추가
        - Phone에게 요금 계산 후 반환되기 전에 적용
        - [Phone] → (`calculateFee(phone)`) → **[TexablePolicy]** → (`calculateFee(phone)`) → [RegularPolicy]
- 부가 정책을 구현하기 위한 **2가지 제약**
    
    (1) 부가 정책은 기본 정책이나 다른 부가 정책의 인스턴스를 참조할 수 있어야 한다. 
    
     = 부가 정책의 인스턴스는 어떤 종류의 정책과도 합성될 수 있어야 한다) 
    
    (2) Phone 입장에서는 자신이 어떤 정책(기본, 부가)의 인스턴스에게 메시지를 전송하고 있는지를 몰라야 한다. 
    
     = 기본, 부가 정책은 협력 내에서 동일 ‘역할’을 수행해야 한다. 이는 부가정책이 기본 정책과 동일한 RatePolicy 인터페이스를 구현해야 한다는 것을 의미한다.
    
    즉, 부가정책은 RatePolicy 인터페이스를 구현해야하며, 내부에 또 다른 RatePolicy 인스턴스를 합성할 수 있어야 한다. 
    
- 부가 정책 - 추상 클래스
    - Phone의 입장에서 부가 정책은 RatePolicy의 역할을 수행하므로 인스턴스를 구현
    
    ```java
    public abstract class AdditionalPolicy implements RatePolicy {
       // 다른 요금 정책과 조합될 수 있도록 RatePolicy 타입의 next 라는 인스턴스 변수를 내부에 포함
        private RatePolicy next;
    
        public AdditionalPolicy(RatePolicy next) {
            this.next = next;
        }
    
        @Override
        public Money calculateFee(Phone phone) {
        // next에게 메시지를 보냄 
            Money fee = next.calculateFee(phone);
            return afterCalculated(fee);
        }
    
        protected abstract Money afterCalculated(Money fee);
    }
    ```
    
- 세금 정책
    
    ```java
    public class TaxablePolicy extends AdditionalPolicy {
        private double taxRatio;
    
        public TaxablePolicy(RatePolicy next, double taxRatio) {
            super(next);
            this.taxRatio = taxRatio;
        }
    
        @Override
        protected Money afterCalculated(Money fee) {
            return fee.plus(fee.times(taxRatio));
        }
    }
    ```
    
- 부가 정책
    
    ```java
    public class RateDiscountablePolicy extends AdditionalPolicy {
        private Money discountAmount;
    
        public RateDiscountablePolicy(RatePolicy next, Money discountAmount) {
            super(next);
            this.discountAmount = discountAmount;
        }
    
        @Override
        protected Money afterCalculated(Money fee) {
            return fee.minus(discountAmount);
        }
    }
    ```
    

### 기본 정책과 부가 정책 합성

- 인스턴스를 생성한 후 의존성 주입을 통해 다른 정책의 인스턴스에 전달하자
    
    ```java
    // 일반 요금제 + 세금 정책
    Phone phone = new Phone(new TaxablePolicy(0.05, new RegularPolicy(...)));
    
    // 일반 요금제 + 기본 할인 정책 + 세금 정책
    Phone phone = new Phone(
                    new TaxablePolicy(0,05,
                            new RateDiscountablePolicy(Money.wons(1000),
                                    new RegularPolicy(...))));
    ```
    
- 상속 방식보다 일관성이 있다는 장점

### 새로운 정책 추가하기

- 상속은 새로운 정책을 추가하기 위해 여러 클래스를 추가해야했지만, 합성은 한 개의 클래스만 추가해도 되도록 한다.
    
    ![스크린샷 2024-11-13 오후 6.06.46.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/47048267-5e3f-44f2-a5ed-20023d68945b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.06.46.png)
    

### 객체 합성이 클래스 상속보다 더 좋은 방법이다.

- 상속은 구현을 재사용하고 합성은 객체의 인터페이스를 재사용한다.
- 상속에는 구현상속과 인터페이스 상속이고
    - 여기서 단점이 있는 상속은 “구현상속”이다.

# (4) 믹스인

- 우리가 원하는 것은 코드를 재사용하면서도 납득할 만한 결합도를 유지하는 것이다.
    - 구체적인 코드를 재사용하면서도 낮은 결합도를 유지할 수 있는 유일한 방법은 재사용에 적합한 추상화를 도입
- 믹스인이란?
    - 상속과 합성의 특성을 모두 보유하고 있는 독특한 코드 재사용 방법
    - 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리킨다.
    - 합성과 다른점
        - 합성이 실행 시점에 객체를 조합하는 재사용 방법이라면, 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법
    - 상속과 다른점
        - 상속은 자식과 부모를 같은 범주로 넣어 is-a관계를 만들기 위한 것
        - 하지만 믹스인은 코드를 다른 코드 안에 섞어 넣기 위한 방법
    - 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용 가능
    

### 기본 정책 구현하기

- 기본 정책에 부가 정책을 자유롭게 조합하기 위해
    - 기본정책을 구현한 후 부가 정책과 관련된 코드를 기본 정책에 어떻게 믹스인 할 수 있는지 고민해야한다.
- 기본 정책을 확장가능하도록  `BasicRatePolicy`  추상 클래스로 구현한다.
    
    ```scala
    abstract class BasicRatePlicy {
    	def calculateFee(phone: Phone): Money =
    		phone.calls.map(calculateCallFee(_)).reduce(_+_)
    
    	protected def calculateCallFee(call: Call): Money;
    }
    ```
    
- 표준 요금제를 구현하는 `RegularPolicy` 는 `BasicRatePolicy` 를 상속받아 `calculateCallFee` 를 오버라이딩한다.
    
    ```scala
    class RegularPolicy(val amount: Money, val seconds: Duration) extends BasicRatePlicy {
    
    	override protected def calculateCallFee(call: Call): Money =
    		amount * (call.duration.getSeconds / seconds.getSeconds)
    }
    ```
    
- 심야 할인 요금제를 구현하기 위해 `NightlyDiscountPolicy` 역시 `BasicRatePolicy` 를 상속받아 `calculateCallFee` 를 오버라이딩한다.
    
    ```scala
    class NightlyDiscountPolicy(
        val nightlyAmount: Money,
        val regularAmount: Money,
        val seconds: Duration) extends BasicRatePolicy {
    
      override protected def calculateCallFee(call: Call): Money =
        if (call.from.getHour >= NightltDiscountPolicy.LateNightHour) {
          nightlyAmount * (call.duration.getSeconds / seconds.getSeconds)
        } else {
          regularAmount * (call.duration.getSeconds / seconds.getSeconds)
        }
    }
    
    object NightltDiscountPolicy {
      val LateNightHour: Integer = 22
    }
    ```
    

### 트레이트로 부가 정책 구현하기

- 기본 정책을 구현한 상속 계층 완성은 기존 자바 예제와 유사하지만 부가 정책 구현 부분은 다르다.
- 트레이트는 스칼라에서 기본 클래스와 결합하여 추가 기능을 주입할 수 있는 기능
    - 트레이트로 구현된 기능들을 섞어 넣게 될 대상은 기본 정책에 해당하는 `RegularPolicy` , `NightlyDiscountPoilcy` 이다.
- 먼저 부가 정책 중 세금 정책에 해당하는 `TaxablePolicy` 트레이트를 구현해보자.
    
    ```scala
    trait TaxablePolicy extends BasicRatePolicy {
    
      val taxRate: Double
    
      override def calculateFee(phone: Phone): Money = {
        val fee = super.calculateFee(phone)
        return fee + fee * taxRate
      }
    }
    ```
    
    - 위 코드에서 트레이트가 `BasicRatePolicy` 를 확장하는 것은, 상속의 개념이 아니라 `TaxablePolicy` 가 `BasicRatePolicy` 나 `BasicRatePolicy` 의 자손에 해당되는 경우에만 믹스인될 수 있다는 의미이다.
    - 유의할 점은 `extends` 문은 상속의 개념이 아닌 단순히 `TaxablePolicy` 가 사용될 문맥을 제한할 뿐이라는 것
        - 따라서 `RegularPolicy` , `NightlyDiscountPolicy` 더 나아가 미래에 추가될 `BaseRatePolicy` 의 자손에게도 믹스인될 수 있고 이외 클래스나 트레이트에는 믹스인될 수 없다.
            - 믹스인은 관계를 고정하는 것이 아니라 어떤 코드에 믹스인 될 것인지를 결정하지 않음
            - 상속은 정적이지만 믹스인은 동적이라는 차이를 발견 가능
                - TaxablePolicy 트레이트는 믹스인하는 시점에 가서야 믹스인할 대상을 결정할 수 있다.
    - 부가 정책은 항상 기본 정책 후에 적용되기 때문에 `super` 호출로 실행되는 `BasicRatePolicy`의 `calcualteFee` 메서드를 실행한 후 자신의 처리를 수행한다.
        - 관계를 고정하지 않기 때문에 super로 참조 되는 코드 역시 고정되지 않는다. 이는 실제 트레이트가 믹스인 되는 시점에 결정된다.
            - ex) RegularPolicy에 믹스인되면 이 클래스의 calculateFee 메서드가 호출될 것이다.
            - 즉, super 참조는 실행 시점에 결정된다.
    - 믹스인은 합성과 유사
        - 합성은 독립적으로 작성된 객체들을 **실행 시점에 조합**해서 더 큰 기능을 만들어내는 데 비해 믹스인은 독립적으로 작성된 객체들을 **코드 작성 시점**에 조합해서 더 큰 기능을 만들어낼 수 있다.

### 부가 정책 트레이트 믹스인하기

- 트레이트 조합
    - 믹스인하려는 대상 클래스의 부모 클래스가 존재하는 경우 부모 클래스는 extends를 이용해 상속받고
    - 트레이트는 with를 이용해 믹스인
- 다음 부가 정책을 `RateDiscountablePolicy` 트레이트로 구현하자.
    
    ```scala
    trait RateDiscountablePolicy extends BasicRatePolicy {
      val discountAmount: Money
    
      override def calculateFee(phone: Phone): Money = {
        val fee = super.calculateFee(phone)
        fee - discountAmount
      }
    }
    ```
    

- 표준 요금제에 세금 정책을 조합해보자.
    - 믹스인할 트레이트 = TaxablePolicy → 상속
    - 조합될 클래스 = RegularPolicy → 트레이트
        - ⇒ 믹스인한 새로운 클래스를 만들 수 있다.
    
    ```scala
    class TaxableRegularPolicy(amount: Money, seconds: Duration, val taxRate: Double)
      extends RegularPolicy(amount, seconds)  // 부모 클래스 상속
      with TaxablePolicy                     // 트레이트 믹스인
    ```
    
    - `RegularPolicy`와 `TaxablePolicy`의 모든 기능을 `TaxableRegularPolicy`에서 사용
    - 스칼라는 특정 클래스에 믹스인한 클래스와 트레이트를 *선형화(linearization)*해서 어떤 메서드를  호출할지 결정한다.
        - 믹스인한 트레이트나 상속한 클래스가 많아질수록 **어떤 순서로 메서드가 호출될지**를 정하는 것이 중요 → 선형화 필요
        - 클래스의 인스턴스를 생성할 때 클래스 자신, 조상 클래스, 트레이트를 일렬로 나열하여 순서를 정하고 실행 중인 메서드 내부에서 `super` 호출을 하면 다음 단계에 위치한 클래스나 트레이트의 메서드가 호출된다.
    - **선형화 규칙**
        1. 선형화를 할 때 항상 맨 앞에는 구현한 클래스 자기 자신이 위치한다. 
        2. **오른쪽부터 왼쪽 순서**로 `with`로 선언된 트레이트가 그 다음 순서에 위치합니다.
        3. **왼쪽으로 이동**하며 나열된 트레이트나 상속된 클래스가 순차적으로 위치하게 됩니다.
        - 예시에서 `TaxableRegularPolicy`가 `RegularPolicy`를 상속받고 `TaxablePolicy`를 믹스인했다면, 호출 순서는 다음과 같습니다:
            - `TaxableRegularPolicy -> TaxablePolicy -> RegularPolicy`
            
            이 순서대로 `super` 호출이 실행됩니다.
            
        - 중요한 것은 믹스인되기 전까지는 상속 계층 안에서 `TaxablePolicy` 트레이트의 위치가 결정되지 않는다는 것이다.
        - 이 위치는 어떤 클래스를 믹스인할지에 따라 동적으로 변한다.
- 심야 할인 요금제 클래스에 RateDiscountablePolicy 트레이트를 믹스인
    
    위와 같이 선형화를 이용한 구조를 만들기 위해선 다음과 같이 코드를 구성할 수 있다.
    
    ```scala
    class RateDiscountableAndTaxableRegularPolicy(
        amount: Money,
        seconds: Duration,
        val discountAmount: Money,
        val taxRate: Double)
      extends RegularPolicy(amount, seconds)
      with TaxablePolicy
      with RateDiscountablePolicy
    ```
    
    - 표준 요금제에 비율 할인 정책을 적용한 후 세금 정책을 적용하고 싶다면 트레이트 순서만 바꾸면 된다.
        
        ```scala
        class TaxableAndRateDiscountableRegularPolicy(
            amount: Money,
            seconds: Duration,
            val discountAmount: Money,
            val taxRate: Double)
          extends RegularPolicy(amount, seconds)
          with RateDiscountablePolicy
          with TaxablePolicy
        ```
        
    - 어떤 사람들은 믹스인을 사용하더라도 클래스 폭발 문제는 여전히 남아있는 것이 아니냐고 반문할 수 있다.
        - 사실 그 문제의 단점은 클래스가 늘어나는 것이 아닌, 클래스 증가에 중복 코드가 기하급수적으로 동반된다는 것이다. 믹스인은 이런 문제가 발생하지 않는다.
    - 클래스를 만들지 않고 인스턴스 생성시 트레이트를 믹스인할 수도 있다.
        
        ```scala
        new RegularPlicy(Money(100), Duration.ofSeconds(10))
        	with RateDiscountablePolicy
        	with TaxablePolicy {
        	val discountAmount = Money(100)
        	val taxRate = 0.02
        }
        ```
        
        이 방법은 RateDiscountablePolicy와 TaxablePolicy를 RegularPolicy에 믹스한 인스턴스가 오직 한 군데에서만 필요한 경우 사용할 수 있다. 
        
        하지만 여러 군데에서 동일한 트레이트를 믹스인해서 사용해야한다면 명시적으로 클래스를 정의하는 것이 좋다. 
        

### 쌓을 수 있는 변경

- 믹스인은 상속 계층 안에서 확장한 클래스보다 더 하위에 위치하게 된다.
    - 다시 말해 믹스인은 대상 클래스의 자식 클래스처럼 사용될 용도로 만들어지는 것이다.
    - 따라서 믹스인을 *추상 서브클래스*라고 부르기도 한다.
- 믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있다. → “쌓을 수 있는 변경”
    - 예시
        
        기본 요금제 클래스에 세금과 할인 기능을 "쌓아올릴" 수 있습니다.
        
        ```java
        class TaxableAndDiscountedPolicy(
        amount: Money, seconds: Duration, val taxRate: Double, val discountAmount: Money)
        extends RegularPolicy(amount, seconds) // 기본 요금제
        with RateDiscountablePolicy           // 비율 할인 정책 추가
        with TaxablePolicy                    // 세금 정책 추가
        ```
        
        이렇게 하면 TaxableAndDiscountedPolicy 클래스는 다음과 같은 순서로 메서드가 호출됩니다:
        
        TaxableAndDiscountedPolicy -> RateDiscountablePolicy -> TaxablePolicy -> RegularPolicy
        
        즉, 할인이 먼저 적용되고, 그 위에 세금이 추가됩니다.
        
    - super가 트레이트를 클래스 구현에 믹스인할 때마다 새로 정해지므로 변경 위에 변경을 쌓아올릴 수 있다.
        - super 키워드는 클래스 계층 구조에서 위쪽 방향의 메서드를 호출하는 역할을 합니다.
        - Scala에서는 믹스인된 트레이트에서 super를 호출할 때 믹스인된 순서에 따라 호출될 메서드가 달라집니다.
        - 이를 통해 각각의 트레이트가 독립적으로 수정된 동작을 정의할 수 있으며, 트레이트를 믹스인할 때마다 super가 동적으로 재정의되어 새로운 변경 사항이 반영됩니다.
        - 즉, 트레이트의 calculateFee 메서드에서 super.calculateFee를 호출하면, 현재 적용된 트레이트 위에 위치한 메서드가 호출됩니다.
        - 이러한 방식으로 변경을 하나씩 쌓아올리면서(super 호출을 통해) 조합된 기능을 사용할 수 있게 됩니다.
