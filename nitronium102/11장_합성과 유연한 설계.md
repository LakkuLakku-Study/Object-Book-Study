# 🔷 상속과 합성

## 상속 vs 합성
### 상속
- 컴파일 타임 의존성 (정적)
- is-a 관계
- 부모 클래스 내부 구현에 강한 결합
- 구현된 코드 재사용

### 합성
- 런타임 의존성 (동적)
- has-a 관계 
- 퍼블릭 인터페이스 의존으로 결합도 낮음
- 내부 구현 변경 영향 최소화

## 1. 상속을 합성으로 변경하기

### 불필요한 인터페이스 상속 문제
```java
// 상속 대신 합성 사용
public class Properties {
    private Hashtable<String, String> properties = new Hashtable<>();
    
    public String setProperty(String key, String value) {
        return properties.put(key, value);
    }
}
```

### 메서드 오버라이딩 해결
```java
public class InstrumentedHashSet<E> implements Set<E> {
    private Set<E> set;
    private int addCount = 0;
    
    // 포워딩을 통해 내부 구현 위임
    @Override
    public boolean add(E e) {
        addCount++;
        return set.add(e); 
    }
}
```

## 2. 상속으로 인한 조합의 폭발적 증가

### 문제점
- 기능 추가마다 불필요한 클래스 증가
- 단일 상속 언어에서 중복 코드 증가
- 수정 시 모든 조합 클래스 변경 필요

## 3. 합성 관계로 변경하기

```java
// 기본 정책 인터페이스
interface RatePolicy {
    calculateFee(phone: Phone): number;
}

// Phone에서 RatePolicy 합성
class Phone {
    private ratePolicy: RatePolicy;
    
    constructor(ratePolicy: RatePolicy) {
        this.ratePolicy = ratePolicy;
    }
}
```

### 장점
- 런타임에 객체 조립 가능
- 새로운 정책 추가 시 클래스 하나만 추가
- 단일 책임 원칙 준수

## 4. 믹스인

### 특징
- 컴파일 시점에 코드 조각 조합
- 코드 재사용을 위한 유연한 방식
- 상속과 달리 관계 재구성 용이

```scala
// 기본 정책 트레이트
trait TaxablePolicy extends BasicRatePolicy {
    def taxRate: Double
    
    override def calculateCallFee(phone: Phone): Integer = {
        val fee = super.calculateFee(phone)
        return fee + fee * taxRate
    }
}

// 믹스인 적용
class TaxablePolicy(amount: Integer, seconds: Integer, val taxRate: Double) 
    extends RegularPolicy(amount, seconds)
    with TaxablePolicy
```

### 장점
- 독립적인 변경사항 쌓기 가능
- 클래스 폭발 문제 해결
- 유연한 기능 조합