# 🔷 상속과 코드 재사용

## 1. 상속과 중복 코드

중복 코드는 요구사항 변경 시 함께 수정되어야 하는 코드로, 유지보수 비용을 증가시키고 버그 발생 가능성을 높인다.

### DRY 원칙 (Don't Repeat Yourself)
- 코드 안에 중복이 존재해서는 안 됨

### 중복 제거 방법

1. **typeCode**
   - 중복 코드를 새로운 클래스로 이관
   - 특정 type에 종속되어 낮은 응집도와 높은 결합도 발생
```java
public enum PhoneType {
    REGULAR, NIGHTLY
}

public class Phone {
    private PhoneType phoneType;
    // ... 구현 생략
}
```

2. **상속**
   - 기반 클래스의 로직 재활용
   - 문제점:
     - 부모-자식 클래스 간 높은 결합도
     - 캡슐화 저하
     - 상속을 고려하지 않은 클래스 상속 시 코드 이해/수정 어려움
     - super 호출로 인한 결합도 증가

## 2. 상속의 문제점

### 취약한 기반 클래스 문제
- 부모 클래스 변경이 자식 클래스에 영향
- 부모 메서드 직접 호출 시 강한 결합

### 불필요한 인터페이스 상속 문제
- 불필요한 메서드/속성 상속
- 부모-자식 클래스 특성 충돌
- 내부 구조 규칙 위반 가능성

### 메서드 오버라이딩 오남용 문제
- 부모 클래스 기능 누락/변경 위험
- 부모 클래스 메서드 사용방식에 자식 클래스가 결합

### 부모-자식 클래스 동시 수정 문제
- 부모 클래스 변경 시 자식 클래스 수정 필요
- 구현 의존으로 인한 변경 전파

## 3. 해결 방법

> 추상화를 사용하라!

### 차이점을 메서드로 추출
- 변하는 것과 변하지 않는 것을 분리
- 변하는 부분 캡슐화

### 중복 코드를 부모 클래스로 이동
- 자식 클래스 코드를 상위로 이동
- 메서드 먼저 이동 후 인스턴스 변수 이동

## 4. 차이에 의한 프로그래밍

> 기존 코드와 다른 부분을 추가하여 애플리케이션 기능을 확장하는 방법

### 상속의 한계
- 코드 재사용의 대표적 방법이나 대부분의 경우 부적절
- 재사용 가능한 단위로 코드 분리/재구성 필요

## 결론

- 중복 제거는 관리 비용 감소가 목적
- 상속은 강한 결합도로 인한 문제 발생
- 구조 설계 없는 상속은 더 큰 문제 초래
- 다음 장에서 **합성**을 통한 대안 제시